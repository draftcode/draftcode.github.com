<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>draftcode.github.com</title><link href="http://draftcode.github.com/" rel="alternate"></link><link href="http://draftcode.github.com//feeds/Python.atom.xml" rel="self"></link><id>http://draftcode.github.com/</id><updated>2013-03-22T14:42:41+09:00</updated><entry><title>PythonのC拡張を書く</title><link href="http://draftcode.github.com/2013/03/22/278e1973-0066-4749-8097-3a7dec906e0e.html" rel="alternate"></link><updated>2013-03-22T14:42:41+09:00</updated><author><name>draftcode</name></author><id>tag:draftcode.github.com,2013-03-22:2013/03/22/278e1973-0066-4749-8097-3a7dec906e0e.html</id><summary type="html">&lt;p&gt;最近はPythonのC拡張を書いていたりするので、覚えている範囲でハマった点を説明します。C拡張を書き始めるには、基本的に&lt;a class="reference external" href="http://docs.python.jp/2/extending/index.html"&gt;Python インタプリタの拡張と埋め込み&lt;/a&gt;をみて、あとは見よう見まねで書きながら&lt;a class="reference external" href="http://docs.python.jp/2/c-api/index.html"&gt;Python/C API リファレンスマニュアル&lt;/a&gt;を見とけばOKです。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;やると良いこと・ハマったこと&lt;/h2&gt;
&lt;div class="section" id="decref"&gt;
&lt;h3&gt;引数はDECREFしてはいけない&lt;/h3&gt;
&lt;p&gt;Pythonのドキュメントをよく読んでないのも悪いのですが、どうやらPythonからCで書かれた関数を呼びだされたときに渡ってくる引数はDECREFしてはいけないようです。
Python組み込みのAPI用意している分にはドキュメントにNew Referenceとか書いてあるのでそれをみて判断すればいいです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="decref2"&gt;
&lt;h3&gt;DECREFの引数は2回以上評価される可能性のあるマクロなので変数のみ渡す&lt;/h3&gt;
&lt;p&gt;同じくDECREF周りですが、Py_DECREFとかはマクロなので引数が複数回評価される可能性があります。というかされます。なので&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Py_DECREF(PyObject_CallFunction(...))&lt;/span&gt;&lt;/tt&gt;みたいなことをすると死にます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cpython"&gt;
&lt;h3&gt;cpythonのソースコードは手元に持っておく&lt;/h3&gt;
&lt;p&gt;正直ドキュメントを参照するよりかはソースコード直接読んだほうが早かったりするので、cpythonのソースコードは手元においておきましょう。というかPythonのスクリプトを書いててもドキュメントに書いてない感じのこととか、曖昧な感じがする点があったりして、そういうときにソースコード手元に持っておくとすぐ確認できて便利です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3&gt;デバッグ版Pythonを使う&lt;/h3&gt;
&lt;p&gt;多分これは自分が高速化のために文字列の可変長配列を自分で持っていたりとか、そういうことをしているからだと思いますが、メモリ周りのエラーで苦しみました。ひたすらSegmentation Faultします。デバッグ版のPythonを使うとメモリまわりでチェックが走るのである程度メモリエラーを検出できます。Pythonは自前でメモリ割り当てを行なっている関係なのか、Valgrindとかを使ってもあんまりInvalid writeみたいなのは検出できなかったです。(Valgrindの仕組みとかよくわかってない)&lt;/p&gt;
&lt;p&gt;デバッグ版Pythonのビルドの仕方は&lt;a class="reference external" href="http://docs.python.org/devguide/"&gt;Python Developer's Guide&lt;/a&gt;に書いてあるのでこれを見て&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--with-pydebug&lt;/span&gt;&lt;/tt&gt;をつければOKです。自分は&lt;a class="reference external" href="https://github.com/yyuu/pyenv"&gt;pyenv&lt;/a&gt;を使っているので、そのプラグインの python-build を改造してデバッグ版ビルドができるようにしました。そのうち整理してPull-Request投げてみるかも。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="yep"&gt;
&lt;h3&gt;yepをつかってプロファイリング&lt;/h3&gt;
&lt;p&gt;&lt;a class="reference external" href="https://pypi.python.org/pypi/yep"&gt;yep&lt;/a&gt;はバックエンドで&lt;a class="reference external" href="https://code.google.com/p/gperftools/"&gt;gperftools&lt;/a&gt;を使ってプロファイリングをしてくれるモジュールです。普通にPython付属のプロファイラだとPythonのコードしかプロファイリングできないので、このモジュールを使ってどこが遅くなっているのかを調べます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;よくわかってないこと&lt;/h2&gt;
&lt;div class="section" id="gc"&gt;
&lt;h3&gt;GC周り&lt;/h3&gt;
&lt;p&gt;どうやらオブジェクト内に外のオブジェクトを含み場合は、普通はGCを有効にしなければいけない感じのようなのですが、別に自分が書いているクラスはユニコード文字列とファイルライクオブジェクトなので、GC周りのフラグを立てていません。GC-awareな書き方は、多分ドキュメント見ればわかるんだろうと思いつつ、よくわかってません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary></entry><entry><title>Windows環境でPythonのC拡張をビルドする</title><link href="http://draftcode.github.com/2013/03/17/5f45fabb-8b64-469e-a0f6-7f9d76564af8.html" rel="alternate"></link><updated>2013-03-17T13:41:45+09:00</updated><author><name>draftcode</name></author><id>tag:draftcode.github.com,2013-03-17:2013/03/17/5f45fabb-8b64-469e-a0f6-7f9d76564af8.html</id><summary type="html">&lt;p&gt;Windows NativeのPythonでC拡張をビルドする方法を説明します。みなさん普通は
WindowsではPythonなんて使わないのか、あんまり情報が無いんですよね……&lt;/p&gt;
&lt;div class="section" id="windows-sdk"&gt;
&lt;h2&gt;Windows SDKをインストールする&lt;/h2&gt;
&lt;p&gt;C拡張なのでCコンパイラが必要なので、コンパイラをインストールします。MicrosoftはVistual Studioを売っているのでそれを買えばコンパイラがついてきます。また、無償版のExpress Editionをインストールしてもコンパイラがついてきます。&lt;/p&gt;
&lt;p&gt;C拡張をうまいことビルドするために、distutilsはVS2008のコンパイラに対応するように書かれています。UNIXだと適当にPATHからコンパイラを探してくれば良いのに、なぜWindowsだとdistutilsがVS2008のための特別な処理を入れているかというと、コンパイラの場所がWindowsだとPATHに入っていなかったりして、レジストリから推測しなければならないからです。残念OSですね……&lt;/p&gt;
&lt;p&gt;レジストリからコンパイラの場所を推測する関係で、より新しいバージョンのVSには対応できていません(レジストリエントリの場所が違うので)。そして、最近対応しているVS2008の(一部のVC++ 2008の)Express Editionのダウンロードができなくなったようです。(&lt;a class="reference external" href="http://mail.python.org/pipermail/python-dev/2013-March/124624.html"&gt;[Python-Dev] VC++ 2008 Express Edition now locked away?&lt;/a&gt;)コンパイラが入手できないのではdistutilsが対応するまでWindows上ではC拡張をビルドすることができません。&lt;/p&gt;
&lt;p&gt;案ずることはありません。まだ道はあります。我々が欲しいのはコンパイラのみです。
MicrosoftはIDEがついてこないコンパイラ単体も配布しています。それがWindows SDKです。ちょっと前までPlatform SDKという名前だった気がします。VS2008のバージョンと互換性があるのは&lt;a class="reference external" href="http://www.microsoft.com/en-us/download/details.aspx?id=3138"&gt;Microsoft Windows SDK for Windows 7 and .NET Framework 3.5 SP1&lt;/a&gt;という
Windows SDKでこちらはまだダウンロード可能です。こちらをインストールしましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vcvarsall-bat"&gt;
&lt;h2&gt;vcvarsall.batをつくる&lt;/h2&gt;
&lt;p&gt;この状態でpython setup.py buildをやるとvcvarsall.batがないという趣旨のことを言われてビルドできません。このvcvarsall.batはVS2010と互換性のあるバージョンのWindows SDKだとついてきているのですが、2008と互換性のあるバージョンのSDKだとついてこないようです。中身は単純で現在のシステムが64bitか32bitかによって(これは引数でも指定できるようです)使うコンパイラを選択するという単純なバッチファイルです。コンパイラの選択もほかのバッチファイルを呼んでいるだけですので、自作しましょう。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;C:\Program&lt;/span&gt; Files &lt;span class="pre"&gt;(x86)\Microsoft&lt;/span&gt; Visual Studio 9.0\VC\vcvarsall.bat&lt;/tt&gt;を作成します。32bit版Pythonを利用している場合は、:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;call &amp;quot;%~dp0bin\vcvars32.bat&amp;quot;
&lt;/pre&gt;
&lt;p&gt;という行を、64bit版の場合は:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;#64;call &amp;quot;%~dp0bin\vcvars64.bat&amp;quot;
&lt;/pre&gt;
&lt;p&gt;という行を一行書いて保存します。64bit版Windowsではない場合は適宜Program Filesを読み替えてください。&lt;/p&gt;
&lt;p&gt;これでC拡張をコンパイルできるようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;より新しいバージョンを利用する方法&lt;/h2&gt;
&lt;p&gt;より新しいバージョンのコンパイラを利用する方法もあります。残念ながらdistutilsは(Python本体がコンパイルされたバージョンである)MSVC2008のコンパイラしか認識してくれないので、その部分をスキップしてPATHから探すようにします。&lt;/p&gt;
&lt;p&gt;環境変数に&lt;tt class="docutils literal"&gt;MSSdk&lt;/tt&gt;と&lt;tt class="docutils literal"&gt;DISTUTILS_USE_SDK&lt;/tt&gt;という変数を追加して下さい。値はなんでも構いません。これによりdistutilsはパスが通っているところからcl.exeやlink.exeを探します。&lt;/p&gt;
&lt;p&gt;この方法の注意点は、Cygwin上でWindowsネイティブのPythonを利用してC拡張のコンパイルをしようとすると、CygwinのGCCのlink.exeが利用されてしまうことと、Python本体と依存するライブラリが変わることです。後者によりpy2exeなどでexeにして配布するときに、実行環境で再頒布可能パッケージがなくて実行できない可能性があります。
(再頒布可能パッケージをインストールすれば実行可能です)&lt;/p&gt;
&lt;/div&gt;
</summary></entry><entry><title>「第八回ありえるえりあ勉強会 ～PyPyのキホンの気」に参加しました</title><link href="http://draftcode.github.com/2012/01/22/005216.html" rel="alternate"></link><updated>2012-01-22T00:00:00+09:00</updated><author><name>draftcode</name></author><id>tag:draftcode.github.com,2012-01-22:2012/01/22/005216.html</id><summary type="html">&lt;p&gt;※酔って書いているのでアレです&lt;/p&gt;
&lt;p&gt;久しぶりの勉強会。今まで出たのがVimの勉強会とかだったので、言語の勉強会は初めてかもしれないですね。あ、Haskellのやつに出たか。となりの研究室の先輩と参加。
JITってどうなってるの、とかPyPyってどういう構成なのとか、PyPyでは内部でこんな事をしてるよという感じの発表で、非常に興味深く聞かせていただきました。&lt;/p&gt;
&lt;p&gt;事前にPyPyのソースコードはダウンロードしていたので、その中を検索しながら聞いていました。最初はshomah4aさんのPyPyの概要の発表で、Python処理系としてのPyPyと言語処理系をつくるためのライブラリとしてのPyPy、という二つの側面があるらしいです。見たところ、それに対応してディレクトリも分かれているようです(pypyの方がそうだったかな)。&lt;/p&gt;
&lt;p&gt;次のcocoatomoさんの発表は静的解析についての話でした。型理論は、研究分野がプログラミング言語理論になるので(研究室でやってることがばらばらなので、これぐらいしか言えない)、割と発表内容的には近いところでした。Types and Programming
Languagesとか輪講で読んでいましたし。ちなみに、アルバイトでVBScriptをがしがし書いていたときは、型が無いのが本当に嫌で、VBScriptの静的解析器を書こうと思っていた時期もありました。&lt;/p&gt;
&lt;p&gt;最後のchlereさんの発表はJITコンパイラについての話で、JITコンパイラがどうやって高速化するべきところを見つけていくのかという話でした。特に、ヒントメカニズムを与えるとこんなに速くなる、というのは驚きました。あと実行時にどうやって実行可能なコードを出力するのかというのに興味があるので、機会があったら聞いてみたいです。&lt;/p&gt;
&lt;p&gt;勉強会が終わった後の懇親会にも参加しました。懇親会だと、いろいろな会社のいろいろな職業の人の話を聞けるので、学生の自分にとっては貴重な機会なんですよ。(と、懇親会に出る度に思います。)&lt;/p&gt;
&lt;p&gt;特に、お向かいの席だったransuiさんのお話がおもしろくて、スピードが命なので、こういうレベルまでチューニングしたりしてますよという話とか、高校生のときにこういう俺俺言語を作ったという話を聞いたりしました。ただ、最近はそういう事をしたいという人があまりいなくて採用が大変みたいです……自分も趣味でアセンブラ作ってみたり、授業でですがFPGAを使った計算機やシミュレータ上でのメモリキャッシュアルゴリズムの実装をしてみたりとか、割と低レベルな話も好きなので、そういう仕事もおもしろそうですね。カーネルの中身とかはまだ見たことが無いので、もっと勉強しないと。&lt;/p&gt;
&lt;p&gt;あと、アリエルのCTOの井上さんとも少しお話をしまして、最近は上流の方にも興味があるんですよと言ったら、若いうちはもっとガシガシ実装して欲しいという言葉をいただきました。ぐぬぬ。ただ、自分の主張を通すために、いろんな立場の人の考え方、ものの見方、背景とかを知っておきたい。そうしないと、下回しが出来ずに主張が通らないというのが嫌なので、プロジェクトのマネジメントをする人たちや、もっと上の経営に関わる人たちが、どういう見方をするのかを知っておきたい。このために事業戦略やプロジェクトマネジメントあたりの本を読んでいたりするので、そこら辺はさじ加減なのかなと思っています。&lt;/p&gt;
&lt;p&gt;というところで、お開きになりました。後で見てみると、cocoatomoさんはCPython
Readingというのを書いていたりするみたいなので、積極的に話に行けば良かった。あと型システムとかが停止するとか安全であるとか、そういうのも聞いてみたかったと、少し後悔しつつ、次の日の「(第15回)Python mini Hack-a-thon」に参加しました。&lt;/p&gt;
</summary></entry><entry><title>CPython2.7.2のWindowsでのmultiprocessingの動作</title><link href="http://draftcode.github.com/2011/12/29/145918.html" rel="alternate"></link><updated>2011-12-29T00:00:00+09:00</updated><author><name>draftcode</name></author><id>tag:draftcode.github.com,2011-12-29:2011/12/29/145918.html</id><summary type="html">&lt;p&gt;フォークが出来るOSであれば、単純にフォークをしてそのあとに&lt;tt class="docutils literal"&gt;Process._bootstrap&lt;/tt&gt;が&lt;tt class="docutils literal"&gt;Process.run&lt;/tt&gt;を呼び出すだけですが、Windowsではプロセスをフォークすることが出来ないので、まっさらなプロセスを立ち上げることになります。このため、ドキュメンテーションに書いてあるとおり、グローバルな変数の中身は親プロセスと違うものになります。また、Windowsではpy2exeのように実行ファイル化されたりします。&lt;/p&gt;
&lt;p&gt;Windowsにおける&lt;tt class="docutils literal"&gt;multiprocessing&lt;/tt&gt;モジュールの動きは次のようなものになります:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;pipeを作っておく。&lt;/li&gt;
&lt;li&gt;現在の実行ファイルに&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--multiprocessing-fork&lt;/span&gt;&lt;/tt&gt;というコマンドラインオプションと先ほどのpipeの読み出し側をつけて&lt;tt class="docutils literal"&gt;CreateProcess&lt;/tt&gt;する。&lt;/li&gt;
&lt;li&gt;親プロセスはpipeを通じて、&lt;tt class="docutils literal"&gt;Process&lt;/tt&gt;オブジェクトを&lt;tt class="docutils literal"&gt;pickle&lt;/tt&gt;で直列化して子プロセスに送る。&lt;/li&gt;
&lt;li&gt;子プロセスは&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--multiprocessing-fork&lt;/span&gt;&lt;/tt&gt;をフラグとして認識して、pipeから&lt;tt class="docutils literal"&gt;Process&lt;/tt&gt;オブジェクトを読み出す。&lt;/li&gt;
&lt;li&gt;子プロセスが&lt;tt class="docutils literal"&gt;Process._bootstrap&lt;/tt&gt;を呼び出す。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Freezeされていない場合は、過程2のところでは、実行ファイルが&lt;tt class="docutils literal"&gt;python.exe&lt;/tt&gt;になるので、-cオプションで過程4を実行するようなプログラムを指定します。Freezeされている場合は、-cのようなオプションを受け取れないので、&lt;tt class="docutils literal"&gt;multiprocessing.freeze_support&lt;/tt&gt;がそのような役割を果たします。これがFreezeされている場合に&lt;tt class="docutils literal"&gt;multiprocessing.freeze_support&lt;/tt&gt;が必要になる理由です。&lt;/p&gt;
</summary></entry><entry><title>CPython2.7.2のcsvモジュールではunicodeを生み出すようなfile-likeオブジェクトを使ってはいけない</title><link href="http://draftcode.github.com/2011/12/29/153703.html" rel="alternate"></link><updated>2011-12-29T00:00:00+09:00</updated><author><name>draftcode</name></author><id>tag:draftcode.github.com,2011-12-29:2011/12/29/153703.html</id><summary type="html">&lt;p&gt;ドキュメンテーションにも書いてあるとおり、&lt;tt class="docutils literal"&gt;csv&lt;/tt&gt;モジュールでは文字列のエンコーディングを正しく取り扱ってくれません。&lt;tt class="docutils literal"&gt;csv&lt;/tt&gt;モジュールのコアの部分はCで書かれており、&lt;tt class="docutils literal"&gt;_csv.c&lt;/tt&gt;というファイルに記述されています。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;csv.Reader&lt;/tt&gt;は与えられたfile-likeオブジェクトから&lt;tt class="docutils literal"&gt;PyString_AsString&lt;/tt&gt;をつかって&lt;tt class="docutils literal"&gt;char *&lt;/tt&gt;を得ようとします。:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;Reader_iternext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ReaderObj&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lineobj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fields&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lineobj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyIter_Next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;input_iter&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PyString_AsString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lineobj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数は&lt;tt class="docutils literal"&gt;char *&lt;/tt&gt;を得るために使われるオブジェクトが&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;か&lt;tt class="docutils literal"&gt;unicode&lt;/tt&gt;かで動作が変わります。&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;であった場合は直接そのオブジェクトのバッファが返されるのですが、&lt;tt class="docutils literal"&gt;unicode&lt;/tt&gt;であった場合は、&lt;tt class="docutils literal"&gt;_PyUnicode_AsDefaultEncodedString&lt;/tt&gt;によって、デフォルトエンコーディングに変換された文字列を返す動作になっています。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*const*/&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="nf"&gt;PyString_AsString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;PyString_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;string_getbuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;PyStringObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ob_sval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nf"&gt;PyString_AsStringAndSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="n"&gt;PyObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="k"&gt;register&lt;/span&gt; &lt;span class="n"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;PyString_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef Py_USING_UNICODE&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PyUnicode_Check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_PyUnicode_AsDefaultEncodedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;このときに変換できないような文字を含んでいた場合は、読み込みが失敗します。もしデフォルトエンコーディングが変更されていた場合は、&lt;tt class="docutils literal"&gt;codecs.open&lt;/tt&gt;を使った場合や&lt;tt class="docutils literal"&gt;open&lt;/tt&gt;を使った場合とでおもしろい?結果が得られるかもしれません。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;csv.Reader&lt;/tt&gt;が返す結果は、&lt;tt class="docutils literal"&gt;unicode&lt;/tt&gt;ではなく、ファイルのエンコーディングでエンコードされたそのままの&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;の配列や辞書になっています。よって、それがきちんと&lt;tt class="docutils literal"&gt;unicode&lt;/tt&gt;なのか、なにかのエンコーディングでエンコードされた&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;なのかを意識しないと、あるはずのキーがないというような現象に出くわしたりします。これを意識するのは面倒くさいので、適切な&lt;tt class="docutils literal"&gt;csv.Reader&lt;/tt&gt;のラッパーを用意して使うようにした方がよいです。&lt;/p&gt;
</summary></entry></feed>