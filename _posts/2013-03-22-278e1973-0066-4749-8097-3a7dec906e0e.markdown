---
layout: post
title:  PythonのC拡張を書く
---

最近はPythonのC拡張を書いていたりするので、覚えている範囲でハマった点を説明し
ます。C拡張を書き始めるには、基本的に
[Python インタプリタの拡張と埋め込み](http://docs.python.jp/2/extending/index.html)
をみて、あとは見よう見まねで書きながら
[Python/C API リファレンスマニュアル](http://docs.python.jp/2/c-api/index.html)
を見とけばOKです。

# やると良いこと・ハマったこと

## 引数はDECREFしてはいけない

Pythonのドキュメントをよく読んでないのも悪いのですが、どうやらPythonからCで書
かれた関数を呼びだされたときに渡ってくる引数はDECREFしてはいけないようです。
Python組み込みのAPI用意している分にはドキュメントにNew Referenceとか書いてある
のでそれをみて判断すればいいです。

## DECREFの引数は2回以上評価される可能性のあるマクロなので変数のみ渡す

同じくDECREF周りですが、 `Py_DECREF` とかはマクロなので引数が複数回評価される
可能性があります。というかされます。なので
`Py_DECREF(PyObject_CallFunction(...))` みたいなことをすると死にます。

## cpythonのソースコードは手元に持っておく

正直ドキュメントを参照するよりかはソースコード直接読んだほうが早かったりするの
で、cpythonのソースコードは手元においておきましょう。というかPythonのスクリプ
トを書いててもドキュメントに書いてない感じのこととか、曖昧な感じがする点があっ
たりして、そういうときにソースコード手元に持っておくとすぐ確認できて便利です。

## デバッグ版Pythonを使う

多分これは自分が高速化のために文字列の可変長配列を自分で持っていたりとか、そう
いうことをしているからだと思いますが、メモリ周りのエラーで苦しみました。ひたす
らSegmentation Faultします。デバッグ版のPythonを使うとメモリまわりでチェックが
走るのである程度メモリエラーを検出できます。Pythonは自前でメモリ割り当てを行
なっている関係なのか、Valgrindとかを使ってもあんまりInvalid writeみたいなのは
検出できなかったです。(Valgrindの仕組みとかよくわかってない)

デバッグ版Pythonのビルドの仕方は
[Python Developer's Guide](http://docs.python.org/devguide/) に書いてあるので
これを見て `--with-pydebug` をつければOKです。自分は
[pyenv](https://github.com/yyuu/pyenv) を使っているので、そのプラグインの
python-build を改造してデバッグ版ビルドができるようにしました。そのうち整理し
てPull-Request投げてみるかも。

## yepをつかってプロファイリング

[yep](https://pypi.python.org/pypi/yep) はバックエンドで
[gperftools](https://code.google.com/p/gperftools/) を使ってプロファイリングを
してくれるモジュールです。普通にPython付属のプロファイラだとPythonのコードしか
プロファイリングできないので、このモジュールを使ってどこが遅くなっているのかを
調べます。

# よくわかってないこと

## GC周り

どうやらオブジェクト内に外のオブジェクトを含み場合は、普通はGCを有効にしなけれ
ばいけない感じのようなのですが、別に自分が書いているクラスはユニコード文字列と
ファイルライクオブジェクトなので、GC周りのフラグを立てていません。GC-awareな書
き方は、多分ドキュメント見ればわかるんだろうと思いつつ、よくわかってません。
