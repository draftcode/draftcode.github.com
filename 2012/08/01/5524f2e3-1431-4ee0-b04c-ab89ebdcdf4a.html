<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <title>第(1+1)回 六本木 Linux カーネル読書会 参加メモ</title>
    <meta content='draftcode' name='author'>
    <meta content='3T_u3CXt1yC2LeNvWOzsMSPQrs_0Ek-XUnA8DYgu7zY' name='google-site-verification'>
    <link href='/stylesheets/old.css' rel='stylesheet'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Sans:400,700|Economica' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div id='content'>
      <div id='article'>
  <div id='content_title'>
    <h1>第(1+1)回 六本木 Linux カーネル読書会 参加メモ</h1>
  </div>
  <div id='posted_date'>
    Posted on 2012-08-01
  </div>
  <div id='content_body'>
    <p><a href="http://connpass.com/event/824/">第(1+1)回 六本木 Linux カーネル読書会</a> に行ってきたので、そのときのメモ。あまりメモがとれていない。今回はforkとかcloneあたり。</p>

<p>後で調べたこともいくつか追加している。</p>
<h2>do_fork (kernel/fork.c)</h2>
<p>do_forkはsys_cloneやsys_vfork、sys_forkから呼ばれる。</p>

<ul>
<li><p>sys_clone</p>

<p>arch/x86/kernel/process.c</p></li>
<li><p>sys_vfork</p>

<p>arch/x86/kernel/process.c</p></li>
<li><p>sys_fork</p>

<p>arch/x86/kernel/process.c</p></li>
<li><p>task_struct</p>

<p>include/linux/sched.h</p></li>
</ul>
<h2>vfork</h2>
<p>古いBSDでfork & execを効率的に行うための仕組み。現在では使われていない。</p>

<p>古いBSDだと、メモリ空間がCopy on Writeではなくて、fork時にコピーするようになっているらしい。このため、fork & execをやろうとすると、無駄にメモリ空間のコピーが走ってしまう。これを防ぐために、vforkというものが生まれた。vforkは子プロセスが親プロセスのメモリ空間を使って動く。このままだと、親プロセスと子プロセスのスタックも共有してしまうので、まず、親プロセスを停止し、次に子プロセスを動かす。子プロセスがexecveを呼ぶかexitするまで、親プロセスは停止する。親プロセスのメモリ空間を利用するため、子プロセスの動きが大きく制約される。</p>

<p><a href="http://surf.ml.seikei.ac.jp/%7Enakano/JMwww/html/LDP_man-pages/man2/vfork.2.html">http://surf.ml.seikei.ac.jp/~nakano/JMwww/html/LDP_man-pages/man2/vfork.2.html</a></p>

<p>現代的なプログラムではvforkは使ってはいけない。</p>

<p><a href="http://www.jpcert.or.jp/sc-rules/c-pos33-c.html">http://www.jpcert.or.jp/sc-rules/c-pos33-c.html</a></p>
<h2>メモリ空間</h2>
<p>カーネル空間とユーザー空間に分かれている。</p>

<ul>
<li><p>__user</p>

<p>include/linux/compiler.h</p></li>
<li><p>__kernel</p>

<p>include/linux/compiler.h</p></li>
</ul>

<p>それぞれでメモリ管理をしているので仮想メモリ空間を指すことになる。</p>

<ul>
<li>copy_process (kernel/fork.c)</li>
</ul>

<p>親プロセスのtask_structをコピーしている。</p>

<ul>
<li>dup_task_structを呼んでる。</li>
<li>sched_forkを呼んでる。</li>
</ul>
<h2>sched_fork (kernel/sched/core.c)</h2>
<p>プロセスが実行される前のスケジューラ周りのセットアップを行うみたい。</p>
<h2>dup_task_struct (kernel/fork.c)</h2>
<p>task_structのメモリ確保はkmem_cache_alloc_nodeで確保している。</p>
<h2>kmem_cache_alloc_node (include/kernel/slab.h)</h2>
<p>カーネル空間のメモリを確保する関数。メモリの種類がいろいろ選べるらしい。</p>

<p><a href="http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html">http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html</a></p>

<p>kmem_cache_alloc_node の node は tsk_fork_get_node から取ってきている。しかしnodeは無視されてしまう。</p>
<h2>tsk_fork_get_node (kernel/kthread.c)</h2>
<p>どうもNUMAアーキテクチャで気にするものらしい。</p>

<p>NUMA は Non-Uniform Memory Access の略で、たしかそれぞれのプロセッサでメモリを持っていて、他のプロセッサが持っているメモリにアクセスするときは、そのプロセッサにお願いして読みに行くというアーキテクチャだったと思う。</p>
<h2>RCUとは</h2>
<p>リードコピーアップデート。wikipedia参照。</p>

<p>どうも、Writerが入るときに、コピーを作ってそっちの方を指すようにする。で、 Readerは読み終わったら上手いことやって、さっきまで見ていた複製元が既に不要になっていたら破棄するようにするものらしい。</p>

<p><a href="http://togetter.com/li/153033">http://togetter.com/li/153033</a></p>
<h2>get_cpu, put_cpu (include/linux/smp.h)</h2>
<ul>
<li><p>get_cpu</p>

<p>CPUの割り込みを禁止し、現在のCPUIDを返す。</p></li>
<li><p>put_cpu</p>

<p>CPUの割り込みを有効化。</p></li>
</ul>
<h2>wake_up_new_task (kernel/sched/core.c)</h2>
<p>do_forkの中で呼び出される。スケジューラに実際に登録する？</p>
<h2>do_execve (fs/exec.c)</h2>
<p>これは次回で。</p>
<h2>Buddy memory allocation と Slab allocator</h2>
<p>kmem_cache_alloc_node が定義されているのはslab.hなので、slabとは何か調べた。</p>

<p>Buddy memory allocationというメモリアロケーションメカニズムがあって、詳しくはわからないけれど、ページ*2^n単位でメモリを確保していくようなものらしい。これで切り取れるのはページ数単位なので、小さいオブジェクトを確保するのには向いていない。なので間にSlab allocatorというものが入って、小さいオブジェクトを切り出していきましょうという仕組みらしい。mallocと変わらない？いくつかの最適化もされるらしい。</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Buddy_memory_system">http://en.wikipedia.org/wiki/Buddy_memory_system</a></li>
<li><a href="http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF">http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF</a></li>
</ul>

<p>そもそもスラブというものが何かというと、同じサイズのオブジェクトを切り出すためのメモリのことらしい。</p>

<p><a href="http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF)">http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF)</a></p>

<p>スラブの割り当て状況みたいなのは/proc/slabinfoで参照できるらしく、さらにtopみたいなslabtopというコマンドもある。</p>

  </div>
</div>

    </div>
    <div id='disclaimer'>
      Disclaimer: The opinions stated here are my own, not necessarily those of my company.
    </div>
  </body>
</html>
