<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>進捗メモ</title>
  <id>http://draftcode.osak.jp/articles</id>
  <link href="http://draftcode.osak.jp/articles"/>
  <link href="http://draftcode.osak.jp/feed.xml" rel="self"/>
  <updated>2015-05-23T00:00:00+09:00</updated>
  <author><name>Masaya SUZUKI</name></author>

  <entry>
    <title>8. [私信] 転籍します</title>
    <link href="http://draftcode.osak.jp/articles/8.html" rel="alternate"/>
    <id>http://draftcode.osak.jp/articles/8.html</id>
    <published>2015-05-23T00:00:00+09:00</published>
    <updated>2015-05-23T00:00:00+09:00</updated>
    <content type="html">&lt;p&gt;一部の人にはこっそりお伝えしていたりしたのですが、Google Inc.へ転籍する運びとなりました。三年で辞める若者どころか、新卒で入った会社を一年で辞めてしまうということになり、若者の離職率を上げるのに貢献してしまったなという感があります。仕事もチームも変更なしなので、特にやることは変わりはありません。強いて言えば、他のチームとのタイムゾーンが同じになったり近くになったりするので、仕事がしやすくなるかもしれないというぐらいですね。&lt;/p&gt;

&lt;p&gt;転籍の副作用として、シリコンバレーあたりに引っ越すことになりました。シリコンバレーといえば、名前の通り高度に遺伝子組み換えが行われたCPUの木からとれる良質なIntelのCPUが主要産業だと思っていたのですが、どうやら最近ではアーモンドを主要な産業としているようです。このアーモンドが水を大量に必要とするために、非常に深刻な水不足に陥っているため、芝生を植えることが禁止されたり、サボテンなどに植え替えていたりするという、まさに&lt;a href=&#34;http://togetter.com/li/806789&#34;&gt;地獄のシリコンバレー&lt;/a&gt;にふさわしい様相を呈していると聞きました。&lt;/p&gt;

&lt;p&gt;引っ越しの時期は7/1を予定しているのですが、実はまだ確定しておりません。社内の手続きはほぼほぼ完了しているのですが、まだビザ取得のプロセスが終わっておらず、予断を許さない状況です。また、カリフォルニアは自動車なしで生活するようには設計されていないということで、&lt;a href=&#34;http://motemen.hatenablog.com/entry/2014/07/09/got-a-license&#34;&gt;泣く泣くスーパーハッカーの夢を諦めて普通自動車免許を取得&lt;/a&gt;しようとしているのですが、こちらの方もまだ終了しておりません。この両方が終了するまではまだ引っ越しができないと思いますので、もし何かしらの事情で僕に寿司や焼き肉をおごる債務を負っているということであれば、柔軟に対応することが可能です。&lt;/p&gt;

&lt;p&gt;このようなお知らせの最後にはAmazonのウィッシュリストへのリンクが貼られているものなのですが、引っ越しをしなければいけない都合上、味噌が10kg送られてきても大変なので、省略させて頂きます。&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>7. RRRSpecについて補足</title>
    <link href="http://draftcode.osak.jp/articles/7.html" rel="alternate"/>
    <id>http://draftcode.osak.jp/articles/7.html</id>
    <published>2014-03-25T00:00:00+09:00</published>
    <updated>2014-03-25T00:00:00+09:00</updated>
    <content type="html">&lt;p&gt;&lt;a href=&#34;http://techlife.cookpad.com/2014/03/24/rrrspec/&#34;&gt;分散テスト実行システムRRRSpecをリリースしました | クックパッド開発者ブログ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;公開したらいろいろ反応があって嬉しいのだけれども、ちょっと補足したいところもあったし、様々な事情により今書いてしまうのが妥当なので、個人の日記でポエムっぽく補足する。&lt;/p&gt;

&lt;h2&gt;名前&lt;/h2&gt;

&lt;p&gt;RRRSpecで「とりぷるあーるすぺっく」。&lt;/p&gt;

&lt;h2&gt;マシンのスケーリングについて&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://xkcd.com/54/&#34;&gt;&lt;img src=&#34;http://imgs.xkcd.com/comics/science.jpg&#34; alt=&#34;Science&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;「なんとか理論」って書いているが、実際のところすごく活用しているわけでは全くない。専門の人からしたら小学生ですか〜と言われるレベルなので、お断りとして大学の学部生が教養で学ぶレベルという形になっている。&lt;/p&gt;

&lt;p&gt;ただ、こういうスケーリングに関係するところで、初歩的な方法ではあっても&amp;quot;It works&amp;quot;な結果が得られているので、勝てば官軍、動けば正義なところはある。実際、オークションの値段を決めるのにも、いくらで入札するのか、いくらまでだったら値上げするのか、落札できなかったときにどういうふうに振る舞うのか、複数のインスタンスタイプに対して複数価格でどういう構成で入札するのか、とかそういう問題が出てくる。こういう問題に対して「ええい」って適当に勘で決めるのと、わからないながらもいろいろ仮定をおきながら数式立てていじってみたら、これ線形計画問題になるじゃんってなってコード書いてシミュレーションして、はいこういう戦略です、っていう感じで決めるのでは、多少安心感に違いがある。やったことは全然大したことではないのだけれども、無いよりマシ、という程度のことはしましたよ、ということ。&lt;/p&gt;

&lt;h2&gt;ソースや設計が汚い件について&lt;/h2&gt;

&lt;p&gt;本当にすまなかったと思っている。しかし、週二回のバイトが成果を出してクビにならないためには、ソースが汚くても前進しなければいけないし、そもそも手探りで進めてきたので「いろいろ問題がわかってから落ち着いて設計しよう」なんてのんきなことは言えなかった。まぁ、これはバイトじゃなくても言えない気がする。&lt;/p&gt;

&lt;p&gt;一応言い訳をすると、そもそもRubyを触りはじめたのがインターンをし始めたときなので2013年5月ぐらいで、「オープンクラスとか何言ってんだよくわかんないぜ」という状況。一緒にインターンしてた大学の同期はBundlerの並列化とかして成果をあげているなか、自分はこれといって成果なし。(ちなみに彼とは大学も一緒、入学年も一緒、専攻も一緒、研究室も一緒で同じく技術部アルバイトで苗字も鈴木。※たぶん公開情報)なので、ソースコード綺麗に書くとか、どうテストするか考えるとかそういうことが全然できずに焦りまくっていたので、コードの汚さはごめんなさいというレベル。むしろこのバイトとは別にもう1つバイトをやりながら修士の研究を進めて卒業までいったのだから偉い。&lt;/p&gt;

&lt;h2&gt;他人の問題を解決できるのかということ&lt;/h2&gt;

&lt;p&gt;まとめで次のように述べた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;同様の問題に直面している方でRRRSpecをそのまま運用できれば嬉しいですし、そうでなくても、RRRSpecで直面した問題とその解決法が、他の同様のシステムや別の問題に対して参考になれば幸いです。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ソフトウェアには二種類あって、他人の問題を解決できる奴と、自分の問題は解決できる奴とがある。RRRSpecは多分後者になる。&lt;/p&gt;

&lt;p&gt;そもそもRRRSpecで実行しなければいけないテストスイートを持っているところが稀だろうし、あっても同じ問題を抱えていないことのほうが多いと思う。もちろん「RRRSpecはRSpecをそのまま置き換えることができて、ただ単にrspecってコマンドを打って実行してたところを、rrrspecって打つようにすれば超早くなるんだぜ。もっと早くしたいなら、rを増やしてrrrrrrrspecってすればもっと早くなるし、rが多すぎたらr7specでもいいんだぜ。」ってなればいいけれども、そうじゃない。&lt;/p&gt;

&lt;p&gt;じゃあ公開したソフトウェアが他人にとって解決法として機能しないのであれば無駄かというとそうではない。そのソフトウェアを作る過程で、どういう問題に直面し、どういうふうに解決したのかというのがわかれば、他人の問題を間接的に解決できる可能性がある。&lt;/p&gt;

&lt;p&gt;あと、大抵のソフトウェアって、わりと再実装されてしまう場合が多いし、腐らないソフトウェアは無いので、定期的に再実装されるのは健全なように思う。自分のように腐っていくソフトウェアを作っている身としては、どうせ再実装されるのであれば、途中で引っかかるであろう問題点とかを事前に出しておいてあげるのがせめてもの貢献ではないだろうか。ということで、RRRSpecでは直面した問題を説明したりとか、実行シーケンスとか、障害発生時の復旧の流れとかを書いている。&lt;/p&gt;

&lt;p&gt;(ここで色々いいそうになったけど、自分の書いたコードはさっき述べたようにクソなので、ここで飲み込んで終わりにする)&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>6. LinuxのUIDのはなし</title>
    <link href="http://draftcode.osak.jp/articles/6.html" rel="alternate"/>
    <id>http://draftcode.osak.jp/articles/6.html</id>
    <published>2014-03-15T00:00:00+09:00</published>
    <updated>2014-03-15T00:00:00+09:00</updated>
    <content type="html">&lt;p&gt;setuidとかseteuidとかの話。いまお行儀のよいdaemonを書こうとおもって、そこら辺を調べていた過程でUIDの話が出てきた。&lt;/p&gt;

&lt;p&gt;実行中のプログラムにはReal UID, Effective UID, Saved UIDの3つがあって、普通は全部一緒になっている。使われるのはEffective UIDで、それ以外はUID操作に関する特殊用途で持っている。&lt;/p&gt;

&lt;h2&gt;Real UIDとEffective UIDのはなし&lt;/h2&gt;

&lt;p&gt;プログラムによっては(Effective) UIDを変更したいことがある。(Effective) UIDを変更したいシチュエーションは2つある&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一時的に(Effective) UIDを変更して、権限を落とす。(後で戻したい)&lt;/li&gt;
&lt;li&gt;恒久的に(Effective) UIDを変更して、権限を落とす。(後で戻せないようにしたい)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一時的なほうは別ユーザーとしてファイルを作りたいときに使って、恒久的なほうはrootで起動されたdaemonの権限を落としたいというときに使うらしい。&lt;/p&gt;

&lt;p&gt;ここで問題なのは、一時的に変更するほうをやりたいときに、単純に一つしかUIDを持っていないと、権限の降格はできても、復帰がセキュリティ上難しくなるということだ。一つしかUIDを持っていないと、次のような2つのUID操作シーケンスが区別できない。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;root -&amp;gt; user -&amp;gt; root&lt;/li&gt;
&lt;li&gt;user -&amp;gt; root&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1はrootから始まってuserに降格した後にrootに復帰している。逆に2はuserがrootに昇格しようとしている。1は許したいが(一時的に権限を落としただけ)、2は勝手にrootになられては困るので、禁止したい。&lt;/p&gt;

&lt;p&gt;ここで、Real UIDとEffective UIDが出てくる。この2つのUIDがあると先の2つのシーケンスが区別できる。&lt;/p&gt;

&lt;p&gt;1の場合、Effective UIDのみ変えればReal UIDはrootのままなので、もともとがrootであると判定できて、復帰できる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | RUID | EUID |
(1) | root | root |
                    &amp;lt;- seteuid(user)
(2) | root | user |
                    &amp;lt;- seteuid(root)
(3) | root | root |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2の場合、Effective UIDをrootにしようとしてもどのUIDもuserなので、昇格は禁止され
る。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | RUID | EUID |
(1) | user | user |
                    &amp;lt;- seteuid(root) EPERM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、恒久的に落としたい場合はReal UIDも変更すればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | RUID | EUID |
(1) | root | root |
                    &amp;lt;- setuid(user)
(2) | user | user |
                    &amp;lt;- seteuid(root) EPERM
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Saved UIDのはなし&lt;/h2&gt;

&lt;p&gt;Linuxではファイルにsetuidというパーミッションが付けられる。これは何かというと、通常の実行可能ファイルは実行ユーザーのReal UIDとEffective UIDを持つようになっているけれども、このパーミッションが付いているファイルはEffective UIDがファイルオーナーの権限になる。例えばuserがrootがオーナーの普通のファイルとrootがオーナーのsetuidファイルを起動すると、起動時のUIDは次のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            | RUID | EUID |
normal file | user | user |
setuid file | user | root |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういう仕組みがあるとなんで便利なのかというと、例えばsudoみたいなプログラムが書けるようになる。rootじゃないといじれないようなリソースを使って動くプログラムで、それを一般ユーザーにも使えるようにさせたいという場合に便利ということらしい。setuidされたファイルはほとんどroot権限なので、以降、setuidファイルはrootオーナーのファイルという前提で話す。&lt;/p&gt;

&lt;p&gt;setuidファイルはEffective UIDがrootになっているが、ここで先のような一時的にUIDを変えたり、恒久的にUIDを変えたりしたいとする。恒久的に変える方はそのまま同じようにsetuidすればいいのだが、一時的に変える方では、root -&amp;gt; user -&amp;gt; rootのようなシーケンスが、Real UIDとEffective UIDだけの世界では実現できない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | RUID | EUID |
(1) | user | root |
                    &amp;lt;- (seteuid)
(2) | user | user |
                    &amp;lt;- (seteuid) EPERM
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで2番めの操作はうまくいって欲しい。そこでSaved UIDが出てくる。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    | RUID | EUID | SUID |
(1) | user | root | root |
                           &amp;lt;- (seteuid)
(2) | user | user | root |
                           &amp;lt;- (seteuid)
(3) | user | root | root |
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにSaved UIDがあると、setuidファイルじゃないときと同じように権限の降格・復帰ができる。&lt;/p&gt;

&lt;p&gt;Real UIDも起動時にファイルオーナーであってもいい気がしてくるが、そうするとsudoが誰のパスワードを聞けばいいのかわからなくなる。やっぱりReal UIDは実行を開始したユーザーである必要がある。&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>5. Backtrace系ライブラリ</title>
    <link href="http://draftcode.osak.jp/articles/5.html" rel="alternate"/>
    <id>http://draftcode.osak.jp/articles/5.html</id>
    <published>2014-03-06T00:00:00+09:00</published>
    <updated>2014-03-06T00:00:00+09:00</updated>
    <content type="html">&lt;p&gt;RubyとかPythonみたいな高級言語だと、言語がうまくやってくれるのでBacktraceを簡単に見ることができるけれども、Cみたいな低級言語でそれを自分でやるのは難しい。なのでライブラリが存在している。Windowsは考えてない。&lt;/p&gt;

&lt;h2&gt;execinfo.h&lt;/h2&gt;

&lt;p&gt;わざわざインストールしなくても動きそうなのが、execinfo.hにあるbacktrace系関数で、man 3 backtraceとかすると見れる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;execinfo.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

void show_backtrace() {
  void *traces[1024];
  int sz = backtrace(traces, 1024);
  backtrace_symbols_fd(traces, sz, STDERR_FILENO);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;backtraceにポインタを格納するための配列を渡すと、そこに戻りアドレスのリストみたいなのを詰め込んでくれる。それを更にbacktrace_symbolsみたいな関数に渡すと、そのアドレスから推測されるバイナリの名前とか関数名とかが書かれた文字列のリストに変換してくれる。この関数名とかはExportされているやつが対象っぽい。&lt;/p&gt;

&lt;p&gt;例えばCRubyのvm_dump.cとかで使われていて、rb_bugでよく見るやつはこれ系をつかって生成してたりする。OSXの実装はちょっと劣っているというか、シグナルハンドラのコンテクストをうまく判定できないらしくて、自分で他のライブラリとかつかって実装している。シグナルトランポリンとかよくわからないので教えてほしい。&lt;/p&gt;

&lt;h2&gt;libunwind&lt;/h2&gt;

&lt;p&gt;execinfo.hのライブラリを更に高機能にしたのがlibunwindで、backtrace関数と互換のあるunw_backtraceを提供している以外にも、スタックの巻き戻しとかもできるっぽい。よく知らないけど、他のプロセスのスタックも見れるんだろうか。ライブラリでの提供なのでいろんなアーキテクチャに頑張って対応している。&lt;/p&gt;

&lt;h2&gt;binutilsのaddr2line&lt;/h2&gt;

&lt;p&gt;binutilsにはaddr2lineというコマンドラインツールがあって、アドレスから関数名の変換をしてくれる。これはDWARFのデバッグ情報を元に、Exportされていない関数の名前まで使ってくれるので、先のexecinfo.hのbackrace_symbolsよりも情報が多くなる。&lt;/p&gt;

&lt;p&gt;CRubyにもどっかから持ってきたのかaddr2line.cってやつがあって、さっきのexecinfo.hで得た情報をもとにして、更にDWARFのデバッグ情報をつかって情報を拾い集めている。&lt;/p&gt;

&lt;h2&gt;libbfd&lt;/h2&gt;

&lt;p&gt;binutilsのaddr2lineのバックにあるのがlibbfdってやつで、オブジェクトファイルの操作をするライブラリらしい。Wikipediaにも載ってる。addr2lineの実装は1ファイルで結構小さいので、このlibbfdをリンクしながらaddr2lineから適宜ソースをパクってくると、コマンドラインからaddr2lineを叩かなくても、自分で自分のデバッグ情報を参照して自分のBacktraceを出力できる偉いプログラムが書ける。&lt;/p&gt;

&lt;p&gt;全然関係ないけど、ibertyっていうライブラリがC++のシンボルのDemangleを行うユーティリティを提供してるみたいなんだけど、この名前がちょうどリンクするときに-libertyっていう名前になってクール。&lt;/p&gt;

&lt;h2&gt;libbacktrace&lt;/h2&gt;

&lt;p&gt;これはよくわからないんだけど、検索してたら出てきたやつ。多分libbfdと同じ感じの動きをしそうなんだけど、よくわからない。GCCとかGDBに最近組み込まれたのかな？自分は使ってみてはない。&lt;/p&gt;

&lt;h2&gt;これで何やったか&lt;/h2&gt;

&lt;p&gt;CRuby使ってるとよくstring.cのAssertion Errorで落ちると思うんだけど、それがなんで起こるのかを調査するために、次のようなpost-conditionをチェックする関数を随所に散りばめた。このpost-conditionはまだ正しくなくて、とりあえずminirubyで落ちてるからもっとRefineしないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static VALUE stringcheck(VALUE str) {
  if (FL_ALL(str, STR_NOEMBED)) {
    if (FL_ALL(str, STR_SHARED)) {
      VALUE shared_buffer = RSTRING(str)-&amp;gt;as.heap.aux.shared;
      char *cache_buffer = RSTRING(str)-&amp;gt;as.heap.ptr;
      long len = RSTRING(str)-&amp;gt;as.heap.len;

      // Shared strings should have a shared buffer.
      bt_assert(shared_buffer != 0);
      // Shared strings should have a cache ptr.
      bt_assert(cache_buffer != NULL);
      // The shared buffer should be frozen.
      bt_assert(OBJ_FROZEN(shared_buffer));
      // The shared buffer should be a valid string.
      stringcheck(shared_buffer);

      if (FL_ALL(shared_buffer, STR_NOEMBED)) {
        // The length should be equal to the shared buffer.
        bt_assert(len &amp;lt;= RSTRING(shared_buffer)-&amp;gt;as.heap.len);
        // The cache ptr should be equal to the shared buffer.
        bt_assert(cache_buffer - (RSTRING(shared_buffer)-&amp;gt;as.heap.len - len) == RSTRING(shared_buffer)-&amp;gt;as.heap.ptr);
      } else {
        // The length should be less than or equal to the shared buffer.
        bt_assert(len == RSTRING_EMBED_LEN(shared_buffer));
        // The cache ptr should be equal to the shared buffer.
        bt_assert(cache_buffer == RSTRING(shared_buffer)-&amp;gt;as.ary);
      }
    } else {
      // Normal strings should have a positive length.
      bt_assert(RSTRING(str)-&amp;gt;as.heap.len &amp;gt;= 0);
      // Normal strings should have a positive capacity.
      bt_assert(RSTRING(str)-&amp;gt;as.heap.aux.capa &amp;gt; 0);
      // The length should be less than or equal to the capacity.
      bt_assert(RSTRING(str)-&amp;gt;as.heap.aux.capa &amp;gt;= RSTRING(str)-&amp;gt;as.heap.len);
      // Normal strings should have a buffer ptr.
      bt_assert(RSTRING(str)-&amp;gt;as.heap.ptr != NULL);
    }
  }
  return str;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでbt_assertっていうのがAssertion違反を起こしたらBacktraceを吐きつつ落ちるマクロなんだけど、ここで出すBacktraceを名前付きにしたいと思って調べたらこんな感じになった。&lt;/p&gt;

&lt;p&gt;実際libbfdでえっちらほっちらやってみたところ、出るには出た。だけど場所が微妙に違ったりしてどうなってるのかよくわからない。自分はexecinfo.hのbacktrace_symbols_fdぐらいの出力で、あとは適当に手でaddr2lineを実行すればいいかなと思った。それかint 3を埋め込む。&lt;/p&gt;

&lt;h2&gt;追記&lt;/h2&gt;

&lt;p&gt;上のコードをビルドが通るところまでなおした。&lt;a href=&#34;https://github.com/draftcode/ruby/tree/string_assertions&#34;&gt;string_assertions&lt;/a&gt;というブランチを作った。まだ必要なところ全部に入れられているわけではない。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;!FL_TEST(str, STR_NOEMBED) なら FL_TEST(str, STR_SHARED) ってことはないよな &lt;a href=&#34;http://t.co/2d5jk5H3ok&#34;&gt;http://t.co/2d5jk5H3ok&lt;/a&gt;&lt;/p&gt;&amp;mdash; なかだ の (@n0kada) &lt;a href=&#34;https://twitter.com/n0kada/statuses/441437990674386944&#34;&gt;2014, 3月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;Embedのときは、STR_SHAREDの部分が長さになっていることに気づいたので、Embedのときのテストを削除した。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;どこで落ちてるのか書いてないけど、STR_SHAREDは必ずしも全体を共有するわけじゃないので cache_buffer == RSTRING(shared_buffer)-&amp;gt;as.heap.ptr はダメだろう &lt;a href=&#34;http://t.co/2d5jk5H3ok&#34;&gt;http://t.co/2d5jk5H3ok&lt;/a&gt;&lt;/p&gt;&amp;mdash; なかだ の (@n0kada) &lt;a href=&#34;https://twitter.com/n0kada/statuses/441448854399889408&#34;&gt;2014, 3月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;気づいて修正。適当に長さの分だけ下げたら同じポインタというのをチェックしている。ちなみに落ちているのはもともとstring.cにあったassert(OBJ_FROZEN(shared));。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;というか if (FL_TEST(str, STR_SHARED)) の中で bt_assert(!FL_TEST(str, STR_SHARED)) はないだろ&lt;/p&gt;&amp;mdash; なかだ の (@n0kada) &lt;a href=&#34;https://twitter.com/n0kada/statuses/441449366230810625&#34;&gt;2014, 3月 6&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;bt_assert(!FL_TEST(shared_buffer, STR_SHARED));の間違いだった。結局、Sharedの階層は必ず2階層のフラットな状態になるわけではなく、dupし続ければ多段になることがわかったので、このテストは外している。&lt;/p&gt;

&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p&gt;そういえば CRuby でCバックトレース欲しい場合は rb_print_backtrace()でおk &lt;a href=&#34;http://t.co/tt0U4HoGHI&#34;&gt;http://t.co/tt0U4HoGHI&lt;/a&gt;&lt;/p&gt;&amp;mdash; 成瀬 (@nalsh) &lt;a href=&#34;https://twitter.com/nalsh/statuses/441873782571945984&#34;&gt;2014, 3月 7&lt;/a&gt;&lt;/blockquote&gt;

&lt;p&gt;rb_bugを使って落とすようにした。&lt;/p&gt;

&lt;p&gt;その他わかったこと:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcc -O3 と gcc -O0 で、if (FL_TEST(...)) の動きが違う。&lt;/li&gt;
&lt;li&gt;引数をvolatileにすると、同様にif (FL_TEST(...)) の動きが違う。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;というかFL_TESTをifの条件部で使うと、何故かどのケースでも正しく判定されない
ケースが発生する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-O0 で volatile にしても動きがおかしい。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;STR_SHAREDが立っていないのに、if (FL_TEST(str, STR_SHARED))が真になる場合がある。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;as.heap.ptrがgdbで見るとnon-nullなのに、bt_assert(RSTRING(str)-&amp;gt;as.heap.ptr != NULL); で落ちる。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;if (FL_TEST(...)) の代わりにif (FL_ALL(...)) を使ったらうまく判定できてい
る。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;何故かas.heap.ptrのやつも引っかからなくなる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>

  <entry>
    <title>4. Linux版Dropboxでアカウント認証できない</title>
    <link href="http://draftcode.osak.jp/articles/4.html" rel="alternate"/>
    <id>http://draftcode.osak.jp/articles/4.html</id>
    <published>2014-02-28T00:00:00+09:00</published>
    <updated>2014-02-28T00:00:00+09:00</updated>
    <content type="html">&lt;p&gt;Dropboxの2.6.13を用いて新規PCをセットアップしようと思うと、アカウントのリンクができない問題があった。通常ならdropboxdを立ち上げると認証用URLが表示されるのだが、このバージョンではされない。多分バグ。&lt;/p&gt;

&lt;p&gt;回避策として、認証だけ前のバージョンを使うとよいらしい。&lt;a href=&#34;https://aur.archlinux.org/packages/dropbox/?comments=all&#34;&gt;AURのdropboxパッケージ&lt;/a&gt;の2014-02-19のコメントにあるように、前のバージョンを落としてきて認証URLを出させ、認証が終了したら消すようにすれば、あとは同期してくれる。&lt;/p&gt;
</content>
  </entry>

</feed>
