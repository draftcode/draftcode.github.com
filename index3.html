<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>draftcode.github.io</title>
    <meta name="author" content="draftcode">
    <meta name="google-site-verification" content="YjRoDozMq67s3NKiyM6spjwqnSVihlZ11ur-OgfZCU0">

    <link href="./theme/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="./theme/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]>
    <link href="./theme/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <![endif]-->

    <link rel="alternate" type="application/atom+xml" title="Atom" href="./atom.xml">
    <link href='http://fonts.googleapis.com/css?family=Economica' rel='stylesheet'>
  </head>

  <body>
    <h1 id="site-title"><a href=".">draftcode.github.io</a></h1>

    <div id="content">
      

<div class='article'>
  <div class="content-title">
    <h1><a href="./2012/10/17/304d5cdb-5069-460f-8c38-e97dc07f5e8c.html">RoboGuice2とRobolectricを組み合わせてテストを書く</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/10/17</dd>
  </dl>

  <div class="content-body section"><p><a class="reference external" href="http://draftcode.github.com/2012/09/23/25036f39-d55f-45b2-97ca-19460353c847.html">RoboGuiceのInjectExtraを使うとテストがしにくくなる件について</a>でActivityの
InjectionタイミングがずれることによりInjectExtraが利用できないことについて述べました。これをRoboGuice2にすることによって回避することができました。</p>
<div class="section" id="id1">
<h2>問題背景</h2>
<p>実機で動く場合は<tt class="docutils literal">RoboActivity.onCreate()</tt>でInjectionが行われますが、
RoboGuice1だと、ActivityをテストにInjectする場合、次のようになってエラーが起きます:</p>
<ol class="arabic simple">
<li>InjectするActivityのIntent付きのオブジェクトをアプリケーションの初めのほうでbindする。</li>
<li>bindするオブジェクトは、更にInjectionが走る。</li>
<li>InjectExtraはContextScopeで走らせないといけない。</li>
</ol>
<p>また、ActivityをテストにInjectしない場合は、RoboGuice1の場合、まともそうな方法でActivityをテストに渡す方法が無さそうです。staticにして渡してしまうのは、ちょっとアレですよね。</p>
</div>
<div class="section" id="roboguice2">
<h2>RoboGuice2でなぜ解決されるのか</h2>
<p>RoboGuice1では、Applicationを継承して自分が必要なbindingを追加していました。しかしRoboGuice2ではApplicationを継承する必要がなくなり、適当なタイミングでbindingを追加できます。これを利用して、テストクラスの中でbindingを追加するようにすれば上記の問題が解決できます。</p>
</div>
<div class="section" id="id2">
<h2>サンプルコード</h2>
<script src="https://gist.github.com/3963845.js"> </script></div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="./2012/09/23/25036f39-d55f-45b2-97ca-19460353c847.html">RoboGuiceのInjectExtraを使うとテストがしにくくなる件について</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/09/23</dd>
  </dl>

  <div class="content-body section"><p>RoboGuiceのInjectなんとか系は記述量が減ってテストもしやすくなって便利ですが、残念ながらInjectExtraだけはイマイチと言わざるを得ません。使っているバーションは、RoboGuice 1.1.2とGuice 2.0 no-aopで、Robolectricでテストを書いたりしています。もしかしたら、RoboGuice 2.0で解消されているのかも知れません。</p>
<div class="section" id="id1">
<h2>問題背景</h2>
<p>まず、実機で動くコードでは、<tt class="docutils literal">RoboActivity.onCreate()</tt>の中でInjectionが行われます。このとき、<tt class="docutils literal">InjectView</tt>以外のフィールドがInjectされます。その中には当然<tt class="docutils literal">InjectExtra</tt>も入っていますので、ここでそのInjectionのContextである
ActivityからIntentがとり出されて、Extraが入ります:</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">SOME_EXTRA_ID</span> <span class="o">=</span> <span class="s">&quot;SOME_EXTRA_ID&quot;</span><span class="o">;</span>
<span class="nd">@InjectExtra</span><span class="o">(</span><span class="n">SOME_EXTRA_ID</span><span class="o">)</span>
<span class="kt">int</span> <span class="n">someExtra</span><span class="o">;</span>
</pre></div>
<p>次に、テストコードの中で、クラス中にテスト対象のActivityをInjectしているとします。このとき、Activityに<tt class="docutils literal">InjectExtra</tt>が入っているとInjectionに失敗してしまいます。失敗する理由としては、次の2つが挙げられます。</p>
<ol class="arabic simple">
<li>Injectionを行うActivityにIntentがセットされていないこと。</li>
<li>Injectionを行うScopeが<tt class="docutils literal">ContextScope</tt>ではないこと。特に、Activityの<tt class="docutils literal">ContextScope</tt>ではないこと。</li>
</ol>
</div>
<div class="section" id="id2">
<h2>解決策</h2>
<p>この2つを回避するために、それなりに現実的な方法で対処をしてみようと試みましたが、根本的に実際に実機で動くときのコードとテスト中のコードでInjectionタイミングが違うことが問題なので、上手く行きませんでした。Activityはどこかほかのオブジェクトの中でInjectされることを、あまり想定していないのです。</p>
<p>大掛かりな解決策としては、<tt class="docutils literal">ExtrasListener</tt>と<tt class="docutils literal">ContextScope</tt>を変更して、<tt class="docutils literal">InjectExtra</tt>が処理されるタイミングを変更するというものがありますが、そこまでして<tt class="docutils literal">InjectExtra</tt>を使いたくありません。</p>
<p>大掛かりな解決策を取らずに<tt class="docutils literal">InjectExtra</tt>を利用したActivityに対してテストを書くのであれば、ActivityはテストコードでのInjecされないようにして、<tt class="docutils literal">setUp</tt>の中で手動Injectするしかありません。その手動Injectを行う場合には、自分でそのActivityの<tt class="docutils literal">ContextScope</tt>を生成して、その中で<tt class="docutils literal">injectMembers</tt>を行う必要があります。この方法を取ると、一見、テストコード中の<tt class="docutils literal">InjectView</tt>が効かなくなりそうですが、どうやら<tt class="docutils literal">ContextScope</tt>のスタックがきちんとしているのか、そのActivityが<tt class="docutils literal">setContentView</tt>をしたときに、きちんとInjectionされます:</p>
<div class="highlight"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">TEST_EXTRA</span> <span class="o">=</span> <span class="mi">42</span><span class="o">;</span>

<span class="nd">@Inject</span>
<span class="n">Injector</span> <span class="n">injector</span><span class="o">;</span>
<span class="nd">@InjectView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">myButton</span><span class="o">)</span>
<span class="n">Button</span> <span class="n">myButton</span><span class="o">;</span>

<span class="kd">private</span> <span class="n">MyActivity</span> <span class="n">activity</span><span class="o">;</span>

<span class="nd">@Before</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
    <span class="n">activity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyActivity</span><span class="o">();</span>
    <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">();</span>
    <span class="n">intent</span><span class="o">.</span><span class="na">putExtra</span><span class="o">(</span><span class="n">MyActivity</span><span class="o">.</span><span class="na">SOME_EXTRA_ID</span><span class="o">,</span> <span class="n">TEST_EXTRA</span><span class="o">);</span>
    <span class="n">activity</span><span class="o">.</span><span class="na">setIntent</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>

    <span class="n">ContextScope</span> <span class="n">scope</span> <span class="o">=</span> <span class="n">injector</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">ContextScope</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">scope</span><span class="o">.</span><span class="na">enter</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
    <span class="n">injector</span><span class="o">.</span><span class="na">injectMembers</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
    <span class="n">scope</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">activity</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<p><tt class="docutils literal">ContextScope</tt>周りは、RoboGuice 2.0では多少改善されているのは確認できました。<tt class="docutils literal">RoboGuice.injectMembers(Context, T)</tt>というメソッドが存在するのが確認できました。</p>
<p>もうひとつの解決策は、もう<tt class="docutils literal">InjectExtra</tt>を使わないという方法で、自分はもうこっちの方法でいいかなと思っています。</p>
</div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="./2012/08/01/5524f2e3-1431-4ee0-b04c-ab89ebdcdf4a.html">第(1+1)回 六本木 Linux カーネル読書会 参加メモ</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/08/01</dd>
  </dl>

  <div class="content-body section"><p><a class="reference external" href="http://connpass.com/event/824/">第(1+1)回 六本木 Linux カーネル読書会</a>に行ってきたので、そのときのメモ。あまりメモがとれていない。今回はforkとかcloneあたり。</p>
<p>後で調べたこともいくつか追加している。</p>
<div class="topic">
<p class="topic-title first">do_fork (kernel/fork.c)</p>
<p>do_forkはsys_cloneやsys_vfork、sys_forkから呼ばれる。</p>
<dl class="docutils">
<dt>sys_clone</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>sys_vfork</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>sys_fork</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>task_struct</dt>
<dd>include/linux/sched.h</dd>
</dl>
</div>
<div class="topic">
<p class="topic-title first">vfork</p>
<p>古いBSDでfork &amp; execを効率的に行うための仕組み。現在では使われていない。</p>
<p>古いBSDだと、メモリ空間がCopy on Writeではなくて、fork時にコピーするようになっているらしい。このため、fork &amp; execをやろうとすると、無駄にメモリ空間のコピーが走ってしまう。これを防ぐために、vforkというものが生まれた。vforkは子プロセスが親プロセスのメモリ空間を使って動く。このままだと、親プロセスと子プロセスのスタックも共有してしまうので、まず、親プロセスを停止し、次に子プロセスを動かす。子プロセスがexecveを呼ぶかexitするまで、親プロセスは停止する。親プロセスのメモリ空間を利用するため、子プロセスの動きが大きく制約される。</p>
<p><a class="reference external" href="http://surf.ml.seikei.ac.jp/~nakano/JMwww/html/LDP_man-pages/man2/vfork.2.html">http://surf.ml.seikei.ac.jp/~nakano/JMwww/html/LDP_man-pages/man2/vfork.2.html</a></p>
<p>現代的なプログラムではvforkは使ってはいけない。</p>
<p><a class="reference external" href="http://www.jpcert.or.jp/sc-rules/c-pos33-c.html">http://www.jpcert.or.jp/sc-rules/c-pos33-c.html</a></p>
</div>
<div class="topic">
<p class="topic-title first">メモリ空間</p>
<p>カーネル空間とユーザー空間に分かれている。</p>
<dl class="docutils">
<dt>__user</dt>
<dd>include/linux/compiler.h</dd>
<dt>__kernel</dt>
<dd>include/linux/compiler.h</dd>
</dl>
<p>それぞれでメモリ管理をしているので仮想メモリ空間を指すことになる。</p>
</div>
<div class="topic">
<p class="topic-title first">copy_process (kernel/fork.c)</p>
<p>親プロセスのtask_structをコピーしている。</p>
<ul class="simple">
<li>dup_task_structを呼んでる。</li>
<li>sched_forkを呼んでる。</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">sched_fork (kernel/sched/core.c)</p>
<p>プロセスが実行される前のスケジューラ周りのセットアップを行うみたい。</p>
</div>
<div class="topic">
<p class="topic-title first">dup_task_struct (kernel/fork.c)</p>
<p>task_structのメモリ確保はkmem_cache_alloc_nodeで確保している。</p>
</div>
<div class="topic">
<p class="topic-title first">kmem_cache_alloc_node (include/kernel/slab.h)</p>
<p>カーネル空間のメモリを確保する関数。メモリの種類がいろいろ選べるらしい。</p>
<p><a class="reference external" href="http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html">http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html</a></p>
<p>kmem_cache_alloc_node の node は tsk_fork_get_node から取ってきている。しかしnodeは無視されてしまう。</p>
</div>
<div class="topic">
<p class="topic-title first">tsk_fork_get_node (kernel/kthread.c)</p>
<p>どうもNUMAアーキテクチャで気にするものらしい。</p>
<p>NUMA は Non-Uniform Memory Access の略で、たしかそれぞれのプロセッサでメモリを持っていて、他のプロセッサが持っているメモリにアクセスするときは、そのプロセッサにお願いして読みに行くというアーキテクチャだったと思う。</p>
</div>
<div class="topic">
<p class="topic-title first">RCUとは</p>
<p>リードコピーアップデート。Wikipedia参照。</p>
<p>どうも、Writerが入るときに、コピーを作ってそっちの方を指すようにする。で、
Readerは読み終わったら上手いことやって、さっきまで見ていた複製元が既に不要になっていたら破棄するようにするものらしい。</p>
<p><a class="reference external" href="http://togetter.com/li/153033">http://togetter.com/li/153033</a></p>
</div>
<div class="topic">
<p class="topic-title first">get_cpu, put_cpu (include/linux/smp.h)</p>
<dl class="docutils">
<dt>get_cpu</dt>
<dd>CPUの割り込みを禁止し、現在のCPUIDを返す。</dd>
<dt>put_cpu</dt>
<dd>CPUの割り込みを有効化。</dd>
</dl>
</div>
<div class="topic">
<p class="topic-title first">wake_up_new_task (kernel/sched/core.c)</p>
<p>do_forkの中で呼び出される。スケジューラに実際に登録する？</p>
</div>
<div class="topic">
<p class="topic-title first">do_execve (fs/exec.c)</p>
<p>これは次回で。</p>
</div>
<div class="topic">
<p class="topic-title first">Buddy memory allocation と Slab allocator</p>
<p>kmem_cache_alloc_node が定義されているのはslab.hなので、slabとは何か調べた。</p>
<p>Buddy memory allocationというメモリアロケーションメカニズムがあって、詳しくはわからないけれど、ページ*2^n単位でメモリを確保していくようなものらしい。これで切り取れるのはページ数単位なので、小さいオブジェクトを確保するのには向いていない。なので間にSlab allocatorというものが入って、小さいオブジェクトを切り出していきましょうという仕組みらしい。mallocと変わらない？いくつかの最適化もされるらしい。</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Buddy_memory_system">http://en.wikipedia.org/wiki/Buddy_memory_system</a></li>
<li><a class="reference external" href="http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF">http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF</a></li>
</ul>
<p>そもそもスラブというものが何かというと、同じサイズのオブジェクトを切り出すためのメモリのことらしい。</p>
<p><a class="reference external" href="http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF">http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF</a>)</p>
<p>スラブの割り当て状況みたいなのは/proc/slabinfoで参照できるらしく、さらに
topみたいなslabtopというコマンドもある。</p>
</div>
</div>
</div>

 
<div class="pagination">
  <ul>
            <a href="./index2.html"><li class="prev">&larr; Previous</li></a>
    
            <a href="./index.html"><li>1</li></a>
                <a href="./index2.html"><li>2</li></a>
                <li class="active">3</li>
                <a href="./index4.html"><li>4</li></a>
                <a href="./index5.html"><li>5</li></a>
                <a href="./index6.html"><li>6</li></a>
                <a href="./index7.html"><li>7</li></a>
        
        <a href="./index4.html"><li class="next">Next &rarr;</li></a>
      </ul>
</div>

 
    </div>

    <div id="footer">
      <div id="footer-container">
        <div id="about">
          <h2>About the author</h2>
          <a href="./pages/about.html"><img src="./static/images/draftcode.png" /></a>
          <p>東京で情報工学を専攻している大学院生です。<br />プログラミング言語の研究をしています。<br /></p>
          <p>詳しくは<a href="./pages/about.html">こちら</a></p>
        </div>

        <div id="site">
          <h2>Site</h2>
          <ul>
            <li><a href="./archives.html">Archives</a>
            <li><a href="./atom.xml" rel="alternate">Atom feed</a></li>
          </ul>
        </div>

        <div id="social">
          <h2>Social</h2>
          <ul>
                        <li class="social"><a href="http://twitter.com/#!/draftcode">Twitter</a></li>            <li class="social"><a href="http://github.com/draftcode">GitHub</a></li>            <li class="social"><a href="https://plus.google.com/107177890582465029754?rel=author">Google+</a></li>          </ul>
        </div>
      </div>
    </div>
  </body>
</html>