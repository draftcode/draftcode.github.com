=============================================
Introduction to Domain TheoryのLecture1を読む
=============================================
:Author: draftcode
:Date:   2012-03-20 21:19:12
:Slug:   e72d8db8-7286-11e1-927a-040ccee352e6

Graham Hutton先生の `Introduction to Domain Theory`_ を読んだメモです。

.. _`Introduction to Domain Theory`:
   http://www.cs.nott.ac.uk/~gmh/domains.html

Denotational Semantics
======================

BNFを使って形式的にAbstract syntaxが定義されたプログラミング言語Pを考えたとき
に、そのPのDenotational semanticsは次の二つから構成されるんだよーという話。

1. a semantic domain for each syntactic category

   ここでいうカテゴリーは、expressionとかcommandとか。

2. a valuation function for each syntactic category

   で、このvaluation functionっていうのはシンタックスの各フレーズに対して、
   semantic domainの中の意味を割り当てるものですよー。

で、なんかvaluation functionはhomomorphismじゃないといけないとしている。この
homomorphismであるということは、各フレーズの意味を割り当てるときは、そのフレー
ズの中のさらに小さいフレーズの意味から構成されるようなことらしい。で、一般的に
はこういう性質のことを、compositionalityと言うらしい。

Foundational Problems
=====================

で、そもそもこのDomain Theoryがなんで生まれたのかというと、Denotational
semanticsがuntyped lambda-calculusに適切な意味を与えられなかったから、生まれた
らしい。

で、じゃあ、なんで与えられなかったのか、というところについて、とりあえず単純に
集合を使って、semantic domainを与えてみようじゃないかということをしてみる。そ
の与えられなかった理由については、主に二つの理由があって:

1. recursively defined programs
2. recursively defined semantic domains

についての問題らしい。

1. Recursively Defined Programs
-------------------------------

なんか直感的には無限ループになるようなプログラムを、ある集合上の関数として対応
づけようとすると、そんな関数はネェってなったり、どんな関数でもそのプログラムに
対応することになってしまったりして、困るという話。

この問題を扱うには「終了しない」ということをsemanticsのレベルで表す必要がある
よね、とも言っている。

2. Recursively Defined Semantic Domains
---------------------------------------

次は、関数とか手続きというものを値として扱えるようになったときに、じゃあ、そう
いった値ってどういう集合なんでしょうねー、関数って言うのは関数から関数への関数
も関数なので、これじゃあ関数の集合っていうのが考えられないですよねーというお
話。

で、関数の集合と同型な集合があればいいかなーとしてみても、やっぱり駄目で、
ちょっと関数の集合の部分集合を考えてみても、濃度的に段違いなんですねー。あー、
可算濃度とか対角線論法とか学部1年のときにやったなー。

A First Step To Scott-Domains : Lifted Sets
===========================================

ということで、やっぱり集合をsemantic domainにするのは無理っぽいので、一つだけ、
なんかエラーとか計算が終了しないとか未定義だとか、そういう値を導入しようという
ことを、どえらい人は考えたんDA!

そういった値である、bottomというものを単純に一つ加えた集合をflat domainとか
lifted setとか呼ぶらしい。で、そういった集合では、bottomとそうじゃない値の間
に、information orderingという関係が定義できるNE!と、言っている。で、この
bottomを含んだ集合をsemantic domainとすると、さっきの1. Recursively Defined
Programsで問題にしていた、終了しないプログラムに意味が与えられるらしい。

Partial Orderings
=================

じゃあ、もうちょっと複雑にして、いくつかの値をとるような関数というものを考えて
みよう、という話。とりあえず、2引数の関数はそれぞれの引数の集合の直積を引数に
とる関数と考えられる。

このとき、それぞれの引数の集合が、flat domainだったら、その直積上にも
information orderingを考えることができる。で、こういう直積はflat setsではなく
てpartially ordered sets(posets)になるね。posetsだから、反射律、対称律、推移律
が成り立つ。もっというと、bottomというものはbasepointというものらしいので、
こういった直積が入ったりすることを考えると、semantic domainsはpointed posetsと
いうことができるらしい。

Monotonic Functions
===================

ということで、semantic domainsを(pointed) posetsにするとすると、プログラムは、
そういったposets上の関数としてモデル化できるはず。でも、そういった関数すべてが
プログラムのモデルとしてふさわしいわけじゃない。

ここからがよくわからなかったんだけれども、入力と出力で、information orderingが
保存されることを要求されるらしい。で、こういった関数のことを、monotonicと呼ぶ
らしい。

なんかこの、計算可能な関数はmonotonicであるとか、情報がたくさんあった方が結果
の情報もたくさんあるというのがよくわからない。じゃあ、逆にmonotonicじゃないと
何がまずいのか、とかもよくわからない。

Excercises
==========

* ::

      E[[proc C]]sigma = proc C
      E[[I]]sigma =  C[[C]]sigma (if I = proc C)
                   | sigma(I) (otherwise)

* 3->3 を書き下すとたぶん10個
* N->M の数は::

      F(N, M) =   1 (if M = 1)
                | M (if N = 1)
                | F(N, M-1) + F(N-1, M)

最後の問題は、chainの元のN個のポイントのうち、一番下のポイントが、M個のポイン
トのどこに写されるのかで場合分けする。

1. 一番下のポイントが先のM個のポイントのうち、一番下以外に写される。

   その数は ``F(N, M-1)`` と等しい。

2. 一番下のポイントが先のM個のポイントのうち、一番下に写される。

   このとき、別に残りのN-1個のポイントがどう写されようと、その対応関係が、
   (N-1)->Mのmonotonic functionであれば、N-1個のポイントの一番下にもう一個付け
   加えて、それがM個のポイントの一番下に写されたものもmonotonic functionにな
   る。つまり、この場合は(N-1)->Mのすべてのmonotonic functionの一番下に割り当
   てを追加してあげれば良いだけ。ということは、その数は ``F(N-1, M)`` と等しい
   ということになる。

