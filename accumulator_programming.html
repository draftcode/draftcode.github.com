<!DOCTYPE html>
<html lang="en">
<head>
        <title>アキュムレータについて</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
                <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="A Pelican Blog Atom Feed" />
                
        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie.css"/>
                <script src="./js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="./">A Pelican Blog </a></h1>
                <nav><ul>
                                                                    <li><a href="./pages/about.html">About</a></li>
                                                                    <li ><a href="./category/android.html">Android</a></li>
                                    <li ><a href="./category/java.html">Java</a></li>
                                    <li ><a href="./category/python.html">Python</a></li>
                                    <li class="active"><a href="./category/articles.html">articles</a></li>
                                    <li ><a href="./category/misc.html">misc</a></li>
                                </ul></nav>
        </header><!-- /#banner -->
        <section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="./accumulator_programming.html" rel="bookmark"
           title="Permalink to アキュムレータについて">アキュムレータについて</a></h1>
          </header>

    <div class="entry-content">
      <footer class="post-info">
        <abbr class="published" title="2010-08-15T00:00:00">
                Sun 15 August 2010
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/draftcode.html">draftcode</a>
        </address>
        <p>In <a href="./category/articles.html">articles</a>. </p>

</footer><!-- /.post-info -->      <p>コンピュータプログラミングの概念・技法・モデルの中で，アキュムレータという概念
が出てきました．たぶん，いろいろなところで使ってきた手法を，一般化して名前をつ
けたため，違うモノのように見えるだけだと思うのですが，混乱しているので整理しま
す．</p>
<div class="section" id="id2">
<h2>再帰計算と反復計算</h2>
<p>宣言的プログラミングにおいては，単純に再帰関数を書いてしまうと効率が悪いことが
多いので，現実的には再帰計算の特殊な場合である，反復計算になるようにプログラム
を書きます．再帰的データ構造を扱う再帰計算を反復計算にするにあたっては，問題を
状態変換の列に作り直す必要がありました．</p>
<p>通常の場合，再帰形を書かずにに反復形を書くことが多いです．その場合に用いられる
形式として，アキュムレータプログラミングという形式があります．</p>
</div>
<div class="section" id="id3">
<h2>反復計算におけるアキュムレータ</h2>
<p>反復計算は次のような制御抽象として表現できました:</p>
<div class="highlight"><pre>proc {Iterate S IsDone Transform ?R}
    if {IsDone S} then R = S
    else S1 in
        S1 = {Transform S}
        {Iterate S1 IsDone Transform R}
    end
end
</pre></div>
<p>アキュムレータは入力と出力の状態の対になります．この場合において， <tt class="docutils literal">S</tt> と
<tt class="docutils literal">R</tt> の対がアキュムレータとなっています．</p>
</div>
<div class="section" id="id4">
<h2>再帰的データ構造を扱う場合の反復計算</h2>
<p>再帰的データ構造を扱う計算をするときに，基本の場合と再帰の場合の二つの場合があ
りました．それを踏まえて，上述の反復計算を書き直すと次のようになります:</p>
<div class="highlight"><pre>proc {P X S1 ?Sn}
    if {BaseCase X} then
        S1 = Sn
    else
        {P1 ．．．S1 S2}
        ．．．
        {Pn ．．．Sm Sn}
    end
end
</pre></div>
<p>基本の場合(<tt class="docutils literal">{BaseCase X} == true</tt> の場合)は，既に状態変換の列の中で，一番最
後の最終状態に居ることになるので，出力状態はそのままになります．</p>
<p>再帰の場合はいくつかの状態変換を施した後，再帰関数を呼んでいます．このとき，呼
んでいる各関数もアキュムレータスタイルで書かれています．そのため，最後に呼ばれ
ている関数では，その関数の出力状態がそのまま，呼び出し元の関数の出力状態
<tt class="docutils literal">Sn</tt> になるようになっています．</p>
</div>
<div class="section" id="id5">
<h2>考察</h2>
<p>最後に再帰関数を呼ぶことによって，末尾再帰最適化がなされる(2章の練習問題で見た
ように，相互再帰では，自分自身の関数以外を呼んでもスタックが一定以上消費されな
い)のですが，その前に関数を呼んでしまうと，関数本体で一度しか再帰関数を呼ばな
いという条件を満たさなくなってしまうので，スタックを一定以上消費しないとは言え
ないと思います．</p>
<p>たぶんアキュムレータスタイルというのは，「再帰計算を反復計算にするときの一般的
な形式」ではなく，「再帰計算を反復計算にした場合のスタイルを一般化した形式」と
して捉えるのが妥当だと思います．アキュムレータスタイルで，再帰の場合の本体で1
つだけ相互再帰集合の関数を呼び出しており，かつその関数が本体の末尾に呼ばれてい
るときのみ，スタックを一定以上消費しない反復計算になるのであって，それ以外の場
合は「あまりメモリを消費しない」再帰計算にとどまると考えられます．このことにつ
いては，アキュムレータスタイルで書かれたマージソートのところでも「メモリ使用量
は少ない」と述べられているだけなので，そういうことでしょう．再帰計算を反復計算
にできる一般的な形式と思って読むと，なんでこれでスタックを消費しないと言える
の?と疑問に思ったりします．</p>
<p>Schemeでは再帰的データ構造としてリストに絞ったアキュムレータを提供していて，次
のようになっています．</p>
<div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fold</span> <span class="nv">kcons</span> <span class="nv">knil</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">l</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">r</span> <span class="nv">knil</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">l</span><span class="p">)</span> <span class="nv">r</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">kcons</span> <span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span> <span class="nv">r</span><span class="p">)))))</span>
</pre></div>
<p>この場合のアキュムレータは <tt class="docutils literal">r</tt> になります．Schemeではすべて関数なので，出力
状態を明示的に指定しなくても良く，対になっているように見えませんが，最後にきち
んと <tt class="docutils literal">r</tt> を返しているので，ここからもアキュムレータが <tt class="docutils literal">r</tt> であることを確認
できます．逆からたどると，初期状態は <tt class="docutils literal">knil</tt> となっていると言えます． <tt class="docutils literal">l</tt>
はリストなので， <tt class="docutils literal">BaseCase</tt> にあたるものは <tt class="docutils literal">null?</tt> になっています．また，
この場合は末尾で直接再帰になっているので，スタックを消費しません．</p>
<div class="section" id="id6">
<h3>蛇足</h3>
<p>Schemeの場合，ある関数を呼び出した後にやるべき計算を取り出せるという機能があっ
て，それは(自分も含めて)多くの人の中で「強力そうなのは知っているが，正直なとこ
ろそれがどういうもので，何に有効なのかよくわからない『継続』」として知られてい
ます．</p>
<p>関数型プログラミングは宣言的プログラミングにおける，部分値を扱うことを制限し
て，完全値のみで計算するようにした計算モデルなので，継続ってある計算をするため
に必要な完全値が計算ができないという理由により，その値を必要とする計算を取り出
しておいて，いったん制御フローを他の部分に移すためのものとしてみれるのではない
でしょうか．それ以外にも，今その値は存在しているけれども，それをつかって計算を
するよりも先に別の計算をしたい場合のフロー制御としても使えるとは思いますが．</p>
</div>
</div>

    </div><!-- /.entry-content -->
    
  </article>
</section>
        <section id="extras" class="body">
                        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>