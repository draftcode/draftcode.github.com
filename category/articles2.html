<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>draftcode.github.io</title>
    <meta name="author" content="draftcode">
    <meta name="google-site-verification" content="YjRoDozMq67s3NKiyM6spjwqnSVihlZ11ur-OgfZCU0">

    <link href="../theme/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../theme/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]>
    <link href="../theme/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <![endif]-->

    <link rel="alternate" type="application/atom+xml" title="Atom" href="../atom.xml">
    <link href='http://fonts.googleapis.com/css?family=Economica' rel='stylesheet'>
  </head>

  <body>
    <h1 id="site-title"><a href="..">draftcode.github.io</a></h1>

    <div id="content">
      

<div class='article'>
  <div class="content-title">
    <h1><a href="../2012/10/17/304d5cdb-5069-460f-8c38-e97dc07f5e8c.html">RoboGuice2とRobolectricを組み合わせてテストを書く</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/10/17</dd>
  </dl>

  <div class="content-body section"><p><a class="reference external" href="http://draftcode.github.com/2012/09/23/25036f39-d55f-45b2-97ca-19460353c847.html">RoboGuiceのInjectExtraを使うとテストがしにくくなる件について</a>でActivityの
InjectionタイミングがずれることによりInjectExtraが利用できないことについて述べました。これをRoboGuice2にすることによって回避することができました。</p>
<div class="section" id="id1">
<h2>問題背景</h2>
<p>実機で動く場合は<tt class="docutils literal">RoboActivity.onCreate()</tt>でInjectionが行われますが、
RoboGuice1だと、ActivityをテストにInjectする場合、次のようになってエラーが起きます:</p>
<ol class="arabic simple">
<li>InjectするActivityのIntent付きのオブジェクトをアプリケーションの初めのほうでbindする。</li>
<li>bindするオブジェクトは、更にInjectionが走る。</li>
<li>InjectExtraはContextScopeで走らせないといけない。</li>
</ol>
<p>また、ActivityをテストにInjectしない場合は、RoboGuice1の場合、まともそうな方法でActivityをテストに渡す方法が無さそうです。staticにして渡してしまうのは、ちょっとアレですよね。</p>
</div>
<div class="section" id="roboguice2">
<h2>RoboGuice2でなぜ解決されるのか</h2>
<p>RoboGuice1では、Applicationを継承して自分が必要なbindingを追加していました。しかしRoboGuice2ではApplicationを継承する必要がなくなり、適当なタイミングでbindingを追加できます。これを利用して、テストクラスの中でbindingを追加するようにすれば上記の問題が解決できます。</p>
</div>
<div class="section" id="id2">
<h2>サンプルコード</h2>
<script src="https://gist.github.com/3963845.js"> </script></div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="../2012/08/01/5524f2e3-1431-4ee0-b04c-ab89ebdcdf4a.html">第(1+1)回 六本木 Linux カーネル読書会 参加メモ</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/08/01</dd>
  </dl>

  <div class="content-body section"><p><a class="reference external" href="http://connpass.com/event/824/">第(1+1)回 六本木 Linux カーネル読書会</a>に行ってきたので、そのときのメモ。あまりメモがとれていない。今回はforkとかcloneあたり。</p>
<p>後で調べたこともいくつか追加している。</p>
<div class="topic">
<p class="topic-title first">do_fork (kernel/fork.c)</p>
<p>do_forkはsys_cloneやsys_vfork、sys_forkから呼ばれる。</p>
<dl class="docutils">
<dt>sys_clone</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>sys_vfork</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>sys_fork</dt>
<dd>arch/x86/kernel/process.c</dd>
<dt>task_struct</dt>
<dd>include/linux/sched.h</dd>
</dl>
</div>
<div class="topic">
<p class="topic-title first">vfork</p>
<p>古いBSDでfork &amp; execを効率的に行うための仕組み。現在では使われていない。</p>
<p>古いBSDだと、メモリ空間がCopy on Writeではなくて、fork時にコピーするようになっているらしい。このため、fork &amp; execをやろうとすると、無駄にメモリ空間のコピーが走ってしまう。これを防ぐために、vforkというものが生まれた。vforkは子プロセスが親プロセスのメモリ空間を使って動く。このままだと、親プロセスと子プロセスのスタックも共有してしまうので、まず、親プロセスを停止し、次に子プロセスを動かす。子プロセスがexecveを呼ぶかexitするまで、親プロセスは停止する。親プロセスのメモリ空間を利用するため、子プロセスの動きが大きく制約される。</p>
<p><a class="reference external" href="http://surf.ml.seikei.ac.jp/~nakano/JMwww/html/LDP_man-pages/man2/vfork.2.html">http://surf.ml.seikei.ac.jp/~nakano/JMwww/html/LDP_man-pages/man2/vfork.2.html</a></p>
<p>現代的なプログラムではvforkは使ってはいけない。</p>
<p><a class="reference external" href="http://www.jpcert.or.jp/sc-rules/c-pos33-c.html">http://www.jpcert.or.jp/sc-rules/c-pos33-c.html</a></p>
</div>
<div class="topic">
<p class="topic-title first">メモリ空間</p>
<p>カーネル空間とユーザー空間に分かれている。</p>
<dl class="docutils">
<dt>__user</dt>
<dd>include/linux/compiler.h</dd>
<dt>__kernel</dt>
<dd>include/linux/compiler.h</dd>
</dl>
<p>それぞれでメモリ管理をしているので仮想メモリ空間を指すことになる。</p>
</div>
<div class="topic">
<p class="topic-title first">copy_process (kernel/fork.c)</p>
<p>親プロセスのtask_structをコピーしている。</p>
<ul class="simple">
<li>dup_task_structを呼んでる。</li>
<li>sched_forkを呼んでる。</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">sched_fork (kernel/sched/core.c)</p>
<p>プロセスが実行される前のスケジューラ周りのセットアップを行うみたい。</p>
</div>
<div class="topic">
<p class="topic-title first">dup_task_struct (kernel/fork.c)</p>
<p>task_structのメモリ確保はkmem_cache_alloc_nodeで確保している。</p>
</div>
<div class="topic">
<p class="topic-title first">kmem_cache_alloc_node (include/kernel/slab.h)</p>
<p>カーネル空間のメモリを確保する関数。メモリの種類がいろいろ選べるらしい。</p>
<p><a class="reference external" href="http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html">http://www.mech.tohoku-gakuin.ac.jp/rde/contents/linux/drivers/tips1.html</a></p>
<p>kmem_cache_alloc_node の node は tsk_fork_get_node から取ってきている。しかしnodeは無視されてしまう。</p>
</div>
<div class="topic">
<p class="topic-title first">tsk_fork_get_node (kernel/kthread.c)</p>
<p>どうもNUMAアーキテクチャで気にするものらしい。</p>
<p>NUMA は Non-Uniform Memory Access の略で、たしかそれぞれのプロセッサでメモリを持っていて、他のプロセッサが持っているメモリにアクセスするときは、そのプロセッサにお願いして読みに行くというアーキテクチャだったと思う。</p>
</div>
<div class="topic">
<p class="topic-title first">RCUとは</p>
<p>リードコピーアップデート。Wikipedia参照。</p>
<p>どうも、Writerが入るときに、コピーを作ってそっちの方を指すようにする。で、
Readerは読み終わったら上手いことやって、さっきまで見ていた複製元が既に不要になっていたら破棄するようにするものらしい。</p>
<p><a class="reference external" href="http://togetter.com/li/153033">http://togetter.com/li/153033</a></p>
</div>
<div class="topic">
<p class="topic-title first">get_cpu, put_cpu (include/linux/smp.h)</p>
<dl class="docutils">
<dt>get_cpu</dt>
<dd>CPUの割り込みを禁止し、現在のCPUIDを返す。</dd>
<dt>put_cpu</dt>
<dd>CPUの割り込みを有効化。</dd>
</dl>
</div>
<div class="topic">
<p class="topic-title first">wake_up_new_task (kernel/sched/core.c)</p>
<p>do_forkの中で呼び出される。スケジューラに実際に登録する？</p>
</div>
<div class="topic">
<p class="topic-title first">do_execve (fs/exec.c)</p>
<p>これは次回で。</p>
</div>
<div class="topic">
<p class="topic-title first">Buddy memory allocation と Slab allocator</p>
<p>kmem_cache_alloc_node が定義されているのはslab.hなので、slabとは何か調べた。</p>
<p>Buddy memory allocationというメモリアロケーションメカニズムがあって、詳しくはわからないけれど、ページ*2^n単位でメモリを確保していくようなものらしい。これで切り取れるのはページ数単位なので、小さいオブジェクトを確保するのには向いていない。なので間にSlab allocatorというものが入って、小さいオブジェクトを切り出していきましょうという仕組みらしい。mallocと変わらない？いくつかの最適化もされるらしい。</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Buddy_memory_system">http://en.wikipedia.org/wiki/Buddy_memory_system</a></li>
<li><a class="reference external" href="http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF">http://wiki.bit-hive.com/linuxkernelmemo/pg/%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF</a></li>
</ul>
<p>そもそもスラブというものが何かというと、同じサイズのオブジェクトを切り出すためのメモリのことらしい。</p>
<p><a class="reference external" href="http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF">http://wiki.bit-hive.com/north/pg/kmalloc(%A5%B9%A5%E9%A5%D6%A5%A2%A5%ED%A5%B1%A1%BC%A5%BF</a>)</p>
<p>スラブの割り当て状況みたいなのは/proc/slabinfoで参照できるらしく、さらに
topみたいなslabtopというコマンドもある。</p>
</div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="../2012/03/20/e72d8db8-7286-11e1-927a-040ccee352e6.html">Introduction to Domain TheoryのLecture1を読む</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2012/03/20</dd>
  </dl>

  <div class="content-body section"><p>Graham Hutton先生の<a class="reference external" href="http://www.cs.nott.ac.uk/~gmh/domains.html">Introduction to Domain Theory</a>を読んだメモです。</p>
<div class="section" id="denotational-semantics">
<h2>Denotational Semantics</h2>
<p>BNFを使って形式的にAbstract syntaxが定義されたプログラミング言語Pを考えたときに、そのPのDenotational semanticsは次の二つから構成されるんだよーという話。</p>
<ol class="arabic">
<li><p class="first">a semantic domain for each syntactic category</p>
<p>ここでいうカテゴリーは、expressionとかcommandとか。</p>
</li>
<li><p class="first">a valuation function for each syntactic category</p>
<p>で、このvaluation functionっていうのはシンタックスの各フレーズに対して、
semantic domainの中の意味を割り当てるものですよー。</p>
</li>
</ol>
<p>で、なんかvaluation functionはhomomorphismじゃないといけないとしている。この
homomorphismであるということは、各フレーズの意味を割り当てるときは、そのフレーズの中のさらに小さいフレーズの意味から構成されるようなことらしい。で、一般的にはこういう性質のことを、compositionalityと言うらしい。</p>
</div>
<div class="section" id="foundational-problems">
<h2>Foundational Problems</h2>
<p>で、そもそもこのDomain Theoryがなんで生まれたのかというと、Denotational
semanticsがuntyped lambda-calculusに適切な意味を与えられなかったから、生まれたらしい。</p>
<p>で、じゃあ、なんで与えられなかったのか、というところについて、とりあえず単純に集合を使って、semantic domainを与えてみようじゃないかということをしてみる。その与えられなかった理由については、主に二つの理由があって:</p>
<ol class="arabic simple">
<li>recursively defined programs</li>
<li>recursively defined semantic domains</li>
</ol>
<p>についての問題らしい。</p>
<div class="section" id="recursively-defined-programs">
<h3>1. Recursively Defined Programs</h3>
<p>なんか直感的には無限ループになるようなプログラムを、ある集合上の関数として対応づけようとすると、そんな関数はネェってなったり、どんな関数でもそのプログラムに対応することになってしまったりして、困るという話。</p>
<p>この問題を扱うには「終了しない」ということをsemanticsのレベルで表す必要があるよね、とも言っている。</p>
</div>
<div class="section" id="recursively-defined-semantic-domains">
<h3>2. Recursively Defined Semantic Domains</h3>
<p>次は、関数とか手続きというものを値として扱えるようになったときに、じゃあ、そういった値ってどういう集合なんでしょうねー、関数って言うのは関数から関数への関数も関数なので、これじゃあ関数の集合っていうのが考えられないですよねーというお話。</p>
<p>で、関数の集合と同型な集合があればいいかなーとしてみても、やっぱり駄目で、ちょっと関数の集合の部分集合を考えてみても、濃度的に段違いなんですねー。あー、可算濃度とか対角線論法とか学部1年のときにやったなー。</p>
</div>
</div>
<div class="section" id="a-first-step-to-scott-domains-lifted-sets">
<h2>A First Step To Scott-Domains : Lifted Sets</h2>
<p>ということで、やっぱり集合をsemantic domainにするのは無理っぽいので、一つだけ、なんかエラーとか計算が終了しないとか未定義だとか、そういう値を導入しようということを、どえらい人は考えたんDA!</p>
<p>そういった値である、bottomというものを単純に一つ加えた集合をflat domainとか
lifted setとか呼ぶらしい。で、そういった集合では、bottomとそうじゃない値の間に、information orderingという関係が定義できるNE!と、言っている。で、このbottomを含んだ集合をsemantic domainとすると、さっきの1. Recursively Defined
Programsで問題にしていた、終了しないプログラムに意味が与えられるらしい。</p>
</div>
<div class="section" id="partial-orderings">
<h2>Partial Orderings</h2>
<p>じゃあ、もうちょっと複雑にして、いくつかの値をとるような関数というものを考えてみよう、という話。とりあえず、2引数の関数はそれぞれの引数の集合の直積を引数にとる関数と考えられる。</p>
<p>このとき、それぞれの引数の集合が、flat domainだったら、その直積上にも
information orderingを考えることができる。で、こういう直積はflat setsではなくてpartially ordered sets(posets)になるね。posetsだから、反射律、対称律、推移律が成り立つ。もっというと、bottomというものはbasepointというものらしいので、こういった直積が入ったりすることを考えると、semantic domainsはpointed posetsということができるらしい。</p>
</div>
<div class="section" id="monotonic-functions">
<h2>Monotonic Functions</h2>
<p>ということで、semantic domainsを(pointed) posetsにするとすると、プログラムは、そういったposets上の関数としてモデル化できるはず。でも、そういった関数すべてがプログラムのモデルとしてふさわしいわけじゃない。</p>
<p>ここからがよくわからなかったんだけれども、入力と出力で、information orderingが保存されることを要求されるらしい。で、こういった関数のことを、monotonicと呼ぶらしい。</p>
<p>なんかこの、計算可能な関数はmonotonicであるとか、情報がたくさんあった方が結果の情報もたくさんあるというのがよくわからない。じゃあ、逆にmonotonicじゃないと何がまずいのか、とかもよくわからない。</p>
</div>
<div class="section" id="excercises">
<h2>Excercises</h2>
<ul>
<li><pre class="first literal-block">
E[[proc C]]sigma = proc C
E[[I]]sigma =  C[[C]]sigma (if I = proc C)
             | sigma(I) (otherwise)
</pre>
</li>
<li><p class="first">3-&gt;3 を書き下すとたぶん10個</p>
</li>
<li><p class="first">N-&gt;M の数は:</p>
<pre class="literal-block">
F(N, M) =   1 (if M = 1)
          | M (if N = 1)
          | F(N, M-1) + F(N-1, M)
</pre>
</li>
</ul>
<p>最後の問題は、chainの元のN個のポイントのうち、一番下のポイントが、M個のポイントのどこに写されるのかで場合分けする。</p>
<ol class="arabic">
<li><p class="first">一番下のポイントが先のM個のポイントのうち、一番下以外に写される。</p>
<p>その数は<tt class="docutils literal">F(N, <span class="pre">M-1)</span></tt>と等しい。</p>
</li>
<li><p class="first">一番下のポイントが先のM個のポイントのうち、一番下に写される。</p>
<p>このとき、別に残りのN-1個のポイントがどう写されようと、その対応関係が、
(N-1)-&gt;Mのmonotonic functionであれば、N-1個のポイントの一番下にもう一個付け加えて、それがM個のポイントの一番下に写されたものもmonotonic functionになる。つまり、この場合は(N-1)-&gt;Mのすべてのmonotonic functionの一番下に割り当てを追加してあげれば良いだけ。ということは、その数は<tt class="docutils literal"><span class="pre">F(N-1,</span> M)</tt>と等しいということになる。</p>
</li>
</ol>
</div>
</div>
</div>

 
<div class="pagination">
  <ul>
            <a href="../category/articles.html"><li class="prev">&larr; Previous</li></a>
    
            <a href="../category/articles.html"><li>1</li></a>
                <li class="active">2</li>
                <a href="../category/articles3.html"><li>3</li></a>
                <a href="../category/articles4.html"><li>4</li></a>
        
        <a href="../category/articles3.html"><li class="next">Next &rarr;</li></a>
      </ul>
</div>

 
    </div>

    <div id="footer">
      <div id="footer-container">
        <div id="about">
          <h2>About the author</h2>
          <a href="../pages/about.html"><img src="../static/images/draftcode.png" /></a>
          <p>東京で情報工学を専攻している大学院生です。<br />プログラミング言語の研究をしています。<br /></p>
          <p>詳しくは<a href="../pages/about.html">こちら</a></p>
        </div>

        <div id="site">
          <h2>Site</h2>
          <ul>
            <li><a href="../archives.html">Archives</a>
            <li><a href="../atom.xml" rel="alternate">Atom feed</a></li>
          </ul>
        </div>

        <div id="social">
          <h2>Social</h2>
          <ul>
                        <li class="social"><a href="http://twitter.com/#!/draftcode">Twitter</a></li>            <li class="social"><a href="http://github.com/draftcode">GitHub</a></li>            <li class="social"><a href="https://plus.google.com/107177890582465029754?rel=author">Google+</a></li>          </ul>
        </div>
      </div>
    </div>
  </body>
</html>