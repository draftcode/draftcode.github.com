<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <title>draftcode.github.io</title>
    <meta name="author" content="draftcode">
    <meta name="google-site-verification" content="YjRoDozMq67s3NKiyM6spjwqnSVihlZ11ur-OgfZCU0">

    <link href="../theme/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../theme/print.css" media="print" rel="stylesheet" type="text/css" />
    <!--[if IE]>
    <link href="../theme/ie.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <![endif]-->

    <link rel="alternate" type="application/atom+xml" title="Atom" href="../atom.xml">
    <link href='http://fonts.googleapis.com/css?family=Economica' rel='stylesheet'>
  </head>

  <body>
    <h1 id="site-title"><a href="..">draftcode.github.io</a></h1>

    <div id="content">
      

<div class='article'>
  <div class="content-title">
    <h1><a href="../2011/03/14/42aa3a98-4e10-11e0-bcea-d8a25efffee9.html">Macを大きいディスプレイにつなげるときはMini DisplayPort &lt;-&gt; DisplayPort変換ケーブルを使う</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2011/03/14</dd>
  </dl>

  <div class="content-body section"><p>Macbook Proを修理に出したときに，どうしてもレポートを書かなければいけない感じだったので，Mac miniを購入しました．Macbook Proは3年ぐらい前のモデルだったので，大きいDVIポートがあり，DELLのU2711のような大きいディスプレイでも直接接続して最適な解像度が出せたのですが，今のMacについているようなMini DisplayPortだと，DVIとの変換ケーブルを使っても，フルHD程度までしか出力することができません．これはDVIのシングルリンクとかデュアルリンクとかの問題らしいんですが，それを解決するためにはAppleの高いデュアルリンク対応の変換アダプタを購入しなければいけません．</p>
<p>もっとシンプルな解決方法を目指します．最近のディスプレイはDisplayPortがついているようなので，それに変換すれば良いのです．実際自分はMini DisplayPortとDisplayPortの変換ケーブルを使って，大きい解像度の出力ができるようになっています．</p>
<p>残念ながら，このような変換ケーブルはあまり製造されていないようです．自分は<a class="reference external" href="http://store.shopping.yahoo.co.jp/ats/0203.html">ATS Direct</a>というサイトで購入しました．</p>
<p>またDisplayPortは音声出力も対応しているので，U2711の音声出力から音を出すこともできています．しかしながらU2711側では音量調節ができないので，音量調節ができるようなもの(スピーカーなど)でないと，音が大きすぎて耳がつぶれます．ヘッドホンとかは難しいです．ちなみに出力切り替えはSoundflowerを使うと便利です．</p>
<div class="section" id="id1">
<h2>追記 (2011-06-22)</h2>
<p>どうも探し方が悪かったようで，他にもいくつか見つかりました．</p>
<ul class="simple">
<li><a class="reference external" href="http://www.amazon.co.jp/dp/B004KB5HM6/">http://www.amazon.co.jp/dp/B004KB5HM6/</a></li>
<li><a class="reference external" href="http://www.amazon.co.jp/dp/B004GCHNP8/">http://www.amazon.co.jp/dp/B004GCHNP8/</a></li>
<li><a class="reference external" href="http://direct.eizo.co.jp/shop/g/gPM200-BK/">http://direct.eizo.co.jp/shop/g/gPM200-BK/</a></li>
</ul>
<p>ただ，ものによっては映らないものもあるみたいですね．</p>
</div>
<div class="section" id="id2">
<h2>追記 (2012-03-11)</h2>
<p>音声出力の切り替えはOptionキーを押しながらメニューバーの音量調節アイコンをクリックすると、出力装置の切り替えができるので、これが便利です。最近はU2711に別のスピーカーをつけて、そのスピーカーについている音声出力端子にヘッドホンをつけたりしています。</p>
</div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="../2010/08/15/accumulator_programming.html">アキュムレータについて</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2010/08/15</dd>
  </dl>

  <div class="content-body section"><p>コンピュータプログラミングの概念・技法・モデルの中で，アキュムレータという概念が出てきました．たぶん，いろいろなところで使ってきた手法を，一般化して名前をつけたため，違うモノのように見えるだけだと思うのですが，混乱しているので整理します．</p>
<div class="section" id="id2">
<h2>再帰計算と反復計算</h2>
<p>宣言的プログラミングにおいては，単純に再帰関数を書いてしまうと効率が悪いことが多いので，現実的には再帰計算の特殊な場合である，反復計算になるようにプログラムを書きます．再帰的データ構造を扱う再帰計算を反復計算にするにあたっては，問題を状態変換の列に作り直す必要がありました．</p>
<p>通常の場合，再帰形を書かずにに反復形を書くことが多いです．その場合に用いられる形式として，アキュムレータプログラミングという形式があります．</p>
</div>
<div class="section" id="id3">
<h2>反復計算におけるアキュムレータ</h2>
<p>反復計算は次のような制御抽象として表現できました:</p>
<div class="highlight"><pre>proc {Iterate S IsDone Transform ?R}
    if {IsDone S} then R = S
    else S1 in
        S1 = {Transform S}
        {Iterate S1 IsDone Transform R}
    end
end
</pre></div>
<p>アキュムレータは入力と出力の状態の対になります．この場合において，<tt class="docutils literal">S</tt>と<tt class="docutils literal">R</tt>の対がアキュムレータとなっています．</p>
</div>
<div class="section" id="id4">
<h2>再帰的データ構造を扱う場合の反復計算</h2>
<p>再帰的データ構造を扱う計算をするときに，基本の場合と再帰の場合の二つの場合がありました．それを踏まえて，上述の反復計算を書き直すと次のようになります:</p>
<div class="highlight"><pre>proc {P X S1 ?Sn}
    if {BaseCase X} then
        S1 = Sn
    else
        {P1 ．．．S1 S2}
        ．．．
        {Pn ．．．Sm Sn}
    end
end
</pre></div>
<p>基本の場合(<tt class="docutils literal">{BaseCase X} == true</tt>の場合)は，既に状態変換の列の中で，一番最後の最終状態に居ることになるので，出力状態はそのままになります．</p>
<p>再帰の場合はいくつかの状態変換を施した後，再帰関数を呼んでいます．このとき，呼んでいる各関数もアキュムレータスタイルで書かれています．そのため，最後に呼ばれている関数では，その関数の出力状態がそのまま，呼び出し元の関数の出力状態<tt class="docutils literal">Sn</tt>になるようになっています．</p>
</div>
<div class="section" id="id5">
<h2>考察</h2>
<p>最後に再帰関数を呼ぶことによって，末尾再帰最適化がなされる(2章の練習問題で見たように，相互再帰では，自分自身の関数以外を呼んでもスタックが一定以上消費されない)のですが，その前に関数を呼んでしまうと，関数本体で一度しか再帰関数を呼ばないという条件を満たさなくなってしまうので，スタックを一定以上消費しないとは言えないと思います．</p>
<p>たぶんアキュムレータスタイルというのは，「再帰計算を反復計算にするときの一般的な形式」ではなく，「再帰計算を反復計算にした場合のスタイルを一般化した形式」として捉えるのが妥当だと思います．アキュムレータスタイルで，再帰の場合の本体で1つだけ相互再帰集合の関数を呼び出しており，かつその関数が本体の末尾に呼ばれているときのみ，スタックを一定以上消費しない反復計算になるのであって，それ以外の場合は「あまりメモリを消費しない」再帰計算にとどまると考えられます．このことについては，アキュムレータスタイルで書かれたマージソートのところでも「メモリ使用量は少ない」と述べられているだけなので，そういうことでしょう．再帰計算を反復計算にできる一般的な形式と思って読むと，なんでこれでスタックを消費しないと言えるの?と疑問に思ったりします．</p>
<p>Schemeでは再帰的データ構造としてリストに絞ったアキュムレータを提供していて，次のようになっています．</p>
<div class="highlight"><pre><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fold</span> <span class="nv">kcons</span> <span class="nv">knil</span> <span class="nv">l</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let </span><span class="nv">loop</span> <span class="p">((</span><span class="nf">l</span> <span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">r</span> <span class="nv">knil</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">l</span><span class="p">)</span> <span class="nv">r</span>
        <span class="p">(</span><span class="nf">loop</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l</span><span class="p">)</span> <span class="p">(</span><span class="nf">kcons</span> <span class="p">(</span><span class="nb">car </span><span class="nv">l</span><span class="p">)</span> <span class="nv">r</span><span class="p">)))))</span>
</pre></div>
<p>この場合のアキュムレータは<tt class="docutils literal">r</tt>になります．Schemeではすべて関数なので，出力状態を明示的に指定しなくても良く，対になっているように見えませんが，最後にきちんと<tt class="docutils literal">r</tt>を返しているので，ここからもアキュムレータが<tt class="docutils literal">r</tt>であることを確認できます．逆からたどると，初期状態は<tt class="docutils literal">knil</tt>となっていると言えます．<tt class="docutils literal">l</tt>はリストなので，<tt class="docutils literal">BaseCase</tt>にあたるものは<tt class="docutils literal">null?</tt>になっています．また，この場合は末尾で直接再帰になっているので，スタックを消費しません．</p>
<div class="section" id="id6">
<h3>蛇足</h3>
<p>Schemeの場合，ある関数を呼び出した後にやるべき計算を取り出せるという機能があって，それは(自分も含めて)多くの人の中で「強力そうなのは知っているが，正直なところそれがどういうもので，何に有効なのかよくわからない『継続』」として知られています．</p>
<p>関数型プログラミングは宣言的プログラミングにおける，部分値を扱うことを制限して，完全値のみで計算するようにした計算モデルなので，継続ってある計算をするために必要な完全値が計算ができないという理由により，その値を必要とする計算を取り出しておいて，いったん制御フローを他の部分に移すためのものとしてみれるのではないでしょうか．それ以外にも，今その値は存在しているけれども，それをつかって計算をするよりも先に別の計算をしたい場合のフロー制御としても使えるとは思いますが．</p>
</div>
</div>
</div>
</div>


<div class='article'>
  <div class="content-title">
    <h1><a href="../2010/08/15/learning_path.html">情報工学科に所属する前後の学習の道筋</a></h1>
  </div>
  <dl class="metadata">
    <dt>Posted</dt>
    <dd>2010/08/15</dd>
  </dl>

  <div class="content-body section"><p>自分も現在学習途中であるし，これはこのように勉強しろというようなたいそうなことは言えないのですが，どういうことを思って，どういう勉強を進めてきたかということを書いてみたいと思います．</p>
<div class="section" id="id2">
<h2>計算機プログラムの構造と解釈を読み始めた</h2>
<p>買ったのは浪人をすることに決めたときでした．そこから4月か5月ぐらいまではやっていたような気がしますが，大して進まずに放置しました．実際に割と進んだのはB2のときでした．ちなみに現在も止まったままです．きっと多くの人が有名な本だし読んでおこうと思いつつも止まっているのではないでしょうか．自分もその一人です．</p>
</div>
<div class="section" id="c">
<h2>プログラミング言語Cを読んだ</h2>
<p>読み始めたのはB1の5月からでした．以前にもCの特に有用ではなさそうな本を読みましたが，情報工学科を志望しているのだしCぐらいできていてもいいのではないだろうかということでこの本だったと思います．この本については演習を含めてだいたい1ヶ月か2ヶ月ぐらいで読み終えたと思います．</p>
</div>
<div class="section" id="id3">
<h2>Cを使うアルバイトを始めた</h2>
<p>プログラミング言語Cを読み終えたので，Cを使うアルバイトをはじめました．現在ではそういうバイトは少なくなっているのかもしれないですが，たまたま見つけたのでそこに応募しました．現在も一応続けています．</p>
</div>
<div class="section" id="mfc">
<h2>MFCに触れた</h2>
<p>アルバイトの研修の最初の方は基本的なCの演習でしたが，後半の方はMFCを使った
Windowsアプリケーションの開発でしたので，MFCに触れることになりました．必然的にC++も触れることになっています．MFCを使うにあたってリファレンスを参照するので，
MSDNをひいていたりしました．</p>
</div>
<div class="section" id="id4">
<h2>プログラミング言語C++を読み始めた</h2>
<p>MFCはC++のフレームワークですので，C++の知識が必要になると思い，プログラミング言語C++を購入しました．この本に関しては評判はイマイチでしたが，言語をデザインした人が書いた本だからという理由で購入しました．</p>
<p>この本はまだ途中までしか読んでいないですし，読んだ部分もほぼ覚えていません．というのも，アルバイトの中で実際に使っているのはC++というよりBetter Cでしたので，C++の様々な機能(と呼んで差し支えないのかわかりませんが)は(幸か不幸か)あまり使用することがなかったのです．</p>
<p>同時期にC++のデザインと進化を購入しましたが，まだ読んでいません．</p>
<div class="section" id="id5">
<h3>この頃のコード</h3>
<p>C++かぶれになっていたので，STLやテンプレートやクラスを多用するコードでした．前述の通り，バイト先ではほぼBetter Cでしたので，書いたコードを社員さんにレビューしてもらうと，(幸か不幸か)反応がイマイチでした．研修の頃は，実際の業務でいじるコードを見ていないので，なんだろうなぁという感想を抱いていましたが，研修が終わり，実際の業務に入ったときにBetter Cのように書いてあるコードをみて，納得がいきました．(そして自分は周りにあわせてCっぽくC++を使うようになりました．)</p>
</div>
</div>
<div class="section" id="win32api">
<h2>Win32APIに触れた</h2>
<p>研修ではMFCを使っていたので，Win32APIを直接使うことはありませんでしたが，実業務ではほぼWin32APIをつかったプログラミングでしたので，MSDNを読みながらプログラムを書くということをやっていました．この時期には古い(Windows95あたりの)Win32APIについての本がバイト先にありましたので，それをめくりつつOSが提供する基本的なサービス，つまりメモリ割り当てやメモリマッピング，スレッド・プロセスの概念，プロセス間同期について知ることとなりました．</p>
</div>
<div class="section" id="id6">
<h2>エキスパートCプログラミングを読んだ</h2>
<p>C++が提供する様々な抽象化は，遊ぶ分には楽しいけれども，適切にそれを使用できる人と一緒ではないと，仕事では使えないという印象を受けたので，C++に関することは中断し，Cについてより詳しく知ることにしました．実際のところプログラミング言語CだけではCについての知識は足りないとは思います．</p>
<p>エキスパートCプログラミングは，そのような足りない部分の一部を補ってくれました．特にポインタと配列の違いは，実際のところこの本を読むまで説明できなかったと思いますし，この本を読むことによって，コードを書くときに意識する視点の一つ，コンパイラは何をどう見るのかという視点を獲得することができました．この視点がないと，sizeofが展開される値についての正しい判断をすることができませんでした．</p>
</div>
<div class="section" id="linkers-loaders">
<h2>Linkers &amp; Loadersを読み始めた</h2>
<p>エキスパートCプログラミングを読んだあと，コンパイラがはき出すオブジェクトコードについての知識が欲しいと思いました．アセンブラについての知識は後で獲得することになるのですが，コンパイル後のコードについて，リンカやローダが行う作業や，オブジェクトコードそれ自体が含むものがなんなのかということについて知ることになりました．</p>
<p>オブジェクトコードが含むものを知ることができたため，コンパイラがどういう視点でソースコードを見ているのかということについて，よりよい推測ができるようになりました．翻訳単位という概念はエキスパートCプログラミングでもありましたが，
Linkers&amp; Loadersを読むことによって，複数のオブジェクトコード間での参照をするときに，どうやって解決しているかということも推測できるようになりました．</p>
<div class="section" id="c-linkers-loaders">
<h3>エキスパートCプログラミング と Linkers &amp; Loadersの与えた影響</h3>
<p>上記の二冊は，自分のコーディングに対する姿勢に大きく影響を与えています．どんなに高級な言語でも，必ずそれは機械語レベルまで落とされるということを強く意識できるようになりました．例えば，自分はアルバイトでVBScriptを書くアルバイトを(上記の仕事とは別に)やっているのですが，そのときもCOMのVariantに意識を落とし，COMが提供するバイナリ標準についての知識を活用しながら，値渡しと参照渡しが混在する関数の間を行き来しています．</p>
<p>また，いかに抽象化されたレイヤで動くプログラムだろうと，それは必ず現実の計算機で実行されているということがはっきりと意識するようになりました．もともと(計算機科学について学習する上で)最初に選んだ本が計算機プログラムの構造と解釈であるのというのもあるかもしれませんが，Lispのようなかなり抽象化のレベルが高い言語が，どうやって計算機の上で動くオブジェクトコードに変換されるのか，ということに関心を寄せるようになりました．</p>
</div>
</div>
<div class="section" id="id7">
<h2>λ計算について知った</h2>
<p>Linkers &amp; Loadersと前後して，チューリング機械や再帰的関数，λ計算についての基本的な知識を得ました．Schemeで出てくるlambdaというものについて知っておきたかったというのもありますし，たまたま大学の授業で計算論の科目があったというのもあります．これらの分野の興味はより進んでいって，サークルで行っている研究室紹介を行うために，関連した研究室へ取材に行くことになりました．</p>
<p>訪問した研究室はプログラム意味論について研究しているところでしたので，初学者の自分にはなかなか理解できなかったところもありましたが，なんとか研究室を紹介できるレベルまでもっていくことができました．また，この時期には論理学についての基礎知識も得ることができました．</p>
</div>
<div class="section" id="id8">
<h2>現在について</h2>
<p>ここまでが情報工学科3年になるまでにたどった学習の道筋です．現在はコンピュータアーキテクチャを学ぶために，パターソン&amp;ヘネシー コンピュータの構成と設計 ハードウエアとソフトウエアのインタフェースを読んでいます．また，アルゴリズムとデータ構造について学ぶために，アルゴリズムイントロダクションを読んでいます．</p>
</div>
</div>
</div>

 
<div class="pagination">
  <ul>
            <a href="../category/articles3.html"><li class="prev">&larr; Previous</li></a>
    
            <a href="../category/articles.html"><li>1</li></a>
                <a href="../category/articles2.html"><li>2</li></a>
                <a href="../category/articles3.html"><li>3</li></a>
                <li class="active">4</li>
        
        <li class="next disabled">&rarr; Next</li>
      </ul>
</div>

 
    </div>

    <div id="footer">
      <div id="footer-container">
        <div id="about">
          <h2>About the author</h2>
          <a href="../pages/about.html"><img src="../static/images/draftcode.png" /></a>
          <p>東京で情報工学を専攻している大学院生です。<br />プログラミング言語の研究をしています。<br /></p>
          <p>詳しくは<a href="../pages/about.html">こちら</a></p>
        </div>

        <div id="site">
          <h2>Site</h2>
          <ul>
            <li><a href="../archives.html">Archives</a>
            <li><a href="../atom.xml" rel="alternate">Atom feed</a></li>
          </ul>
        </div>

        <div id="social">
          <h2>Social</h2>
          <ul>
                        <li class="social"><a href="http://twitter.com/#!/draftcode">Twitter</a></li>            <li class="social"><a href="http://github.com/draftcode">GitHub</a></li>            <li class="social"><a href="https://plus.google.com/107177890582465029754?rel=author">Google+</a></li>          </ul>
        </div>
      </div>
    </div>
  </body>
</html>